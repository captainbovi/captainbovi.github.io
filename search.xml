<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎来到我的博客</title>
    <url>/2022/04/01/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>我的本意其实并不是打算搭一个个人网站，只是想找个地方记录一下自己的一些学习笔记罢了。后来经过一些机缘巧合，我接触到了个人网站这一神奇的东西，同时还要感谢我的好兄弟王力可对我赞助（在此再次感谢），才让这一网站顺利搭成。不过由于服务器雀食太贵了，所以连夜携博文跑路，投奔github page的怀抱。不过github page中的博文中的图片总是会加载超时，将图片路径从网络移步到相对路径后（将图片存至github中），依然没有改观，所以部分文章也正搬至掘金社区里<a href="https://juejin.cn/user/3593635986943031">captainbovi 的个人主页 - 动态 - 掘金 (juejin.cn)</a>（文章下方有链接）。</p>
<p>（原网站：<a href="http://capbv.top/">http://capbv.top</a>   不知道读者看到这儿的时候这个网站是否还存活</p>
<blockquote>
<p>没有斗争就没有功绩，没有功绩就没有奖赏，而没有行动就没有生活。</p>
<p><em>别林斯基</em></p>
</blockquote>
<p>里面的每一篇博客，都是我对于学习上的记录，记录内容也均为我个人的所观所感,部分文章摘用了一些写的很好的文章，文章下部会有原文链接，各位看官觉得文章中存在错误，还请联系我对文章进行更改！谢谢各位。</p>
<p>本博客主要用于记录学习，其他关于生活方面的博文放在我的个人公众号里：点滴生活 点滴人生。</p>
<p>人生活在希望之中，各位，愿世间安稳，岁月静好。</p>
]]></content>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2022/04/14/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是KMP算法"><a href="#什么是KMP算法" class="headerlink" title="什么是KMP算法"></a>什么是KMP算法</h2><p>KMP算法由Knuth、Morris和Pratt三位学者发明，这个算法取三主要名字的首字母，故叫做KMP算法。</p>
<p>这个算法用于<strong>字符串匹配</strong>，其核心思想就是利用已经匹配的部分，来简化整个重新匹配的机制，避免每次匹配失败都从头再来。</p>
<span id="more"></span>

<p>这么做，还是为了节约时间成本，花费额外的空间，来实现对时间复杂度的大幅减轻。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们先来看一个经典例子：</p>
<p>给出一个文本串：aabaabaaf</p>
<p>和一个模式串：    aabaaf    </p>
<p>需要我们在文本串中找出第一个匹配模式串的位置。</p>
<h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>当然，我们还是可以使用非常暴力的算法对此进行解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for( i = 0; i&lt;wenBenChuan.length;i++)&#123;</span><br><span class="line">    for(let n = 0 ;n&lt; moShiChuan.length;)&#123;</span><br><span class="line">    if(wenBenChuan[i+n] == moShiChuan[n]&amp;&amp;wenBenChuan[i+moShiChuan.length] ==moShiChuan[moShiChuan.length -1])&#123;</span><br><span class="line">    n++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n == moShiChuan.length-1)</span><br><span class="line">    return i+1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，在双循环的顶级加持之下，暴力算法的时间复杂度到达了傲人的o(n*n)，我们对暴力法进行拷打后发现，只要出现字符串不匹配，暴力法都会选择前功尽弃，然后首位向后移动一格，重新做人，这样无疑会使时间复杂度高举不下。</p>
<p>结合上述案例，也就是当我们从第一个开始寻找匹配至aabbaa时，下一个字符f是无法和文本串中的b配对的，此时暴力法将会非常无脑的从第二个字符即第二个a开始搜寻，这无疑让搜寻花费的时间陡然上涨。</p>
<p>那么有没有一种方法，使得时间复杂度能够得到一个维度的下降呢？</p>
<p>方法是有的，但既然我们想要直接降低时间复杂度，代价往往就是会牺牲空间复杂度。既然暴力法选择前功尽弃，那我们就需要对“前功”进行考虑、分析、并加工，让其辅助我们定位下一个寻找的起始点。而参考“前功”时，我们需要用到<strong>前缀表</strong>！！！</p>
<h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>这里我们不由得提出两个问题：什么是前缀表？为什么是前缀表？</p>
<p>前缀表是用于记录最长前后缀的表，最长前后缀，即一个字符串中的前缀和后缀相同的部分的长（取最大值，但长度小于该字符串本身），例如aabaa的最长前后缀为2，abcab的最长前后缀为2，abcba的最长前后缀为1，abccbb的最长前后缀为0。aabaaf的前缀表如下</p>
<p>下标         0    1    2    3   4    5</p>
<p>​                 a    a    b    a   a    f</p>
<p>前缀表     0     1    0   1   2    0</p>
<p>知道了前缀表里面的内容是什么，那为什么要使用前缀表呢？</p>
<p>既然我们已经知道了一个字符串的最长前后缀，那就可以利用它进行简化跳跃，例如上例中，当我们匹配到f时，发现匹配失败，此时我们观察此刻已经完成匹配字符串的前缀表，不难发现下标为4时（aabaa）对应的最长前后缀的值最大（2），下标为4前的字符串中，**前两个字符（aa）和后两个字符相同(aa)<strong>，也就是说用于被匹配的</strong>字符串（文本串）中匹配出错的字符（b)前面的两个字符 **(aa)和用于匹配的字符串（模式串）的前面两个字符相同（模式串前两个字符 &#x3D;&#x3D; 模式串后两个字符   模式串后两个字符 &#x3D;&#x3D; 文本串中匹配出错的字符前面的两个字符）</p>
<p>由于文本串目前指向位置（b）的前面两个字符和模式串的前面两个字符相同，所以当我们开始新一轮匹配时，可以理所应当的跳到模式串的第三个字符和文本串进行匹配。</p>
<p>简而言之，完成匹配的模式串的前缀表中最大值对应的下标字符及其之前的字符中，存在部分相同的前缀和后缀（我们将之成为公共前后缀），每当我们进行下一次匹配时，将公共前缀移动至上一次公共后缀的位置，便可实现快速定位，继续进行匹配。</p>
<p>这就是KMP算法的核心思想，若N为模式串长度，M为文本串长度，那么KMP算法的时间复杂度就是o(m+n)。</p>
<h2 id="前缀表的实现"><a href="#前缀表的实现" class="headerlink" title="前缀表的实现"></a>前缀表的实现</h2><p>我们先对前缀表（此后称为next数组)进行生成。声明一个函数getNext(int* next, const string* s) —此处使用C++语言，具体思想不变。</p>
<p>先对该函数进行一个初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next[1]=0;</span><br><span class="line">//next[j]：其值=第J字符前面j-1为字符组成的子串的最大前后缀值+1，此处next数组从下标1开始有意义</span><br><span class="line">int i=1,j=0;</span><br><span class="line">//i为next数组的索引，同时也是当前主串正在匹配的字符位置</span><br></pre></td></tr></table></figure>

<p>函数实现的核心想法：<strong>如果next[j]不等于Pj，那么next[j+1]可能的次大值为next[next[j]+1]，以此类推即可高效求出next[j+1]，每一次只需要找到当前子串索引j对应的字符、前缀表索引j对应的值m，以及子串索引m对应的字符，并将这两个字符进行对比</strong></p>
<p>(说的很好，下次别再说了)</p>
<p>那这是为什么捏，我们不妨从一个例子进行推理。</p>
<p>已知next[1],next[2]….next[j]，求next[j+1]</p>
<p>我们假设<strong>next[j+1]&#x3D;k</strong>，那么前k-1个字符和后k-1个字符重合，即P1P2…Pk-1&#x3D;Pj-k+1…..Pj-1</p>
<p>如果Pk &#x3D; Pj,那么P1P2…Pk&#x3D;Pj-k+1…..Pj，即前k个字符和后k个字符重合，则<strong>next[j+1]&#x3D;k+1</strong></p>
<p>若二者不等，假设next[k]&#x3D;m(k一定小于j)，则有P1…Pm&#x3D;Pk-m+1…Pk</p>
<p>故，得：<strong>P1…Pm&#x3D;Pk-m+1…Pk&#x3D;pJ-K+1…Pm-k+j-1&#x3D;Pj-m+1…..Pj-1</strong>(根据P1P2…Pk-1&#x3D;Pj-k+1…..Pj-1可得)，即前m-1个字符和后m-1个字符重合，此时，如果Pm &#x3D;Pj，那么next[j+1]&#x3D;m+1,反之则重复上述步骤，继续进行递推。</p>
<p>还不懂？“偷”几张图看看</p>
<p><img src="/2022/04/14/KMP%E7%AE%97%E6%B3%95/Users/12628\AppData\Roaming\Typora\typora-user-images\image-20220421230104485.png" alt="image-20220421230104485"></p>
<p><img src="/2022/04/14/KMP%E7%AE%97%E6%B3%95/Users/12628\AppData\Roaming\Typora\typora-user-images\image-20220421230226429.png" alt="image-20220421230226429"></p>
<p><img src="/2022/04/14/KMP%E7%AE%97%E6%B3%95/Users/12628\AppData\Roaming\Typora\typora-user-images\image-20220421230343335.png" alt="image-20220421230343335"></p>
<p><img src="/2022/04/14/KMP%E7%AE%97%E6%B3%95/Users/12628\AppData\Roaming\Typora\typora-user-images\image-20220421230647405.png" alt="image-20220421230647405"></p>
<p>实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void getNext(int* next, const string* s)&#123;</span><br><span class="line">	next[1]=0;</span><br><span class="line">	inti=1,j=0;</span><br><span class="line">	while(i&lt;=s.length)&#123;</span><br><span class="line">		if(j==0 || s[i]==s[j]) next[++i] = ++j;</span><br><span class="line">		else j = next[j]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>非父子组件间的通信</title>
    <url>/2022/04/04/%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>Vue中父子组件间进行通信可以使用 refs或refs 或refs或children 来进行父组件访问子组件的操作，通过$parent进行子组件访问父组件的操作(详情见文章<a href="https://juejin.cn/post/7082437425108090917">组件访问（父访子 与 子访父） - 掘金 (juejin.cn)</a>), 那么如何实现非父子组件间的通信呢？基本思路如下：</p>
<span id="more"></span>

<h4 id="使用Vue-prototype"><a href="#使用Vue-prototype" class="headerlink" title="使用Vue.prototype"></a>使用Vue.prototype</h4><p><strong>使用prototype原型挂载属性，来作为全局变量</strong></p>
<p>1.创建js文件，声明变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let gl_value = undefined;</span><br><span class="line">export default &#123;gl_value&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.main.js文件中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lue from &#x27;../static/js/commonvue&#x27;</span><br><span class="line">Vue.prototype.$GLOBAL = gl_value;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>3.调用<br> 组件A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$GLOBAL.gl_value = “组件A的值”; //修改值</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>组件B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">this.msg = this.$GLOBAL.gl_value；//接收值</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="使用vuex"><a href="#使用vuex" class="headerlink" title="使用vuex"></a>使用vuex</h4><p>大致思路和使用<strong>prototype原型挂载属性</strong>相同，<strong>我们可以把公用的数据使用vuex来进行存储，可以在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。</strong></p>
<p>.创建一个js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">// 存储共用的数据</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">state:&#123;</span><br><span class="line">value:&quot;vuex值&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2.在main.js文件中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import store from &#x27;../static/js/commonvue&#x27;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &#x27;#app&#x27;,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: &#x27;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>3.使用时直接调用<br> 组件A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">this.$store.state.value = “组件A的值”; //修改值</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>组件B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">this.msg = this.$store.state.value；//接收值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>链接：<a href="https://juejin.cn/post/7082445786356645902">https://juejin.cn/post/7082445786356645902</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式原理</title>
    <url>/2022/04/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>vue是如何实现响应式的？ 随之而来便有两个问题：</p>
<ul>
<li><p>vue是如何实现监听实例中的属性的变化的</p>
</li>
<li><p>当数据发生变化时，vue是如何做到通知相应的组件，并使界面实现刷新</p>
<span id="more"></span></li>
</ul>
<h4 id="vue是如何实现监听实例中的属性的变化的"><a href="#vue是如何实现监听实例中的属性的变化的" class="headerlink" title="vue是如何实现监听实例中的属性的变化的"></a>vue是如何实现监听实例中的属性的变化的</h4><p>vue通过设置Object.defineProperty() 来监听对象属性的改变。</p>
<p>我们不妨回到一个最简单的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el:&#x27;app&#x27;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:&#x27;我是data&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时页面是这样监听message的：</p>
<ol>
<li>先在内部拿到一个对象obj（内容即data中的内容）</li>
<li>然后通过 Object.defineProperty对原本data中的属性进行重新定义具体操作如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Object.keys(obj).forEach(key =&gt;&#123;</span><br><span class="line">        // 将obj中的每一个属性（key）中的值赋值到value中</span><br><span class="line">        let value = obj[key]</span><br><span class="line">        // 使用defineProperty将每个value在obj中进行定义，一旦数值发生改变，便会调用set函数</span><br><span class="line">        Object.defineProperty(obj,key,&#123;</span><br><span class="line">            set(newValue)&#123;</span><br><span class="line">                value = newValue</span><br><span class="line">            &#125;,</span><br><span class="line">            get()&#123;</span><br><span class="line">                return value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="当数据发生变化时，vue是如何做到通知相应的组件，并使界面实现刷新"><a href="#当数据发生变化时，vue是如何做到通知相应的组件，并使界面实现刷新" class="headerlink" title="当数据发生变化时，vue是如何做到通知相应的组件，并使界面实现刷新"></a>当数据发生变化时，vue是如何做到通知相应的组件，并使界面实现刷新</h4><p>vue通过发布订阅者模式，实现通知。所谓发布订阅者模式，就是谁在使用特定属性（通过解析html文件得知），该属性更新时就会通知该组件（使用get函数获取最新的数值），该模式的大致实现思路如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发布者</span><br><span class="line">    class dep&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line">            this.subs=[]</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加订阅者</span><br><span class="line">        addSub(watcher)&#123;</span><br><span class="line">            this.subs.push(watcher)</span><br><span class="line">        &#125;</span><br><span class="line">        // 通知订阅者进行更新</span><br><span class="line">        notify()&#123;</span><br><span class="line">            this.subs.forEach(item =&gt;&#123;</span><br><span class="line">                item.update()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 订阅者</span><br><span class="line">    class watcher&#123;</span><br><span class="line">        constructor(name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //更新函数</span><br><span class="line">        update()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    const dep = new dep();</span><br><span class="line">    const w1 = new watcher(&#x27;张三&#x27;)</span><br><span class="line">    dep.addSub(w1)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>了解完响应式原理实现的两大重要技术后，我们重温一下响应式的原理图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7397769e0c8840078cf47c5505ae2803~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>原理图</p>
<p>我们在生成一个实例之后，里面的数据就换传入observer中（通过defineProperty实现），里面的每一个key都将会对应生成一个dep对象。在解析的时候，每解析到一个key时，都会生成一个watcher并将其添加到对应dep对象中的subs数组中（发布订阅者模式），而当某个key的值发生改变的时候，便会调用该key对应的dep对象中的notify函数，并通知该dep的所有订阅者调用update函数，最后更新视图，实现响应式。</p>
<p>链接：<a href="https://juejin.cn/post/7082445269245100040">https://juejin.cn/post/7082445269245100040</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/2022/04/04/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>Vue实例从创建直至销毁的过程，叫做Vue的生命周期。即开始创建、初始化数据、编译模板、挂载dom、渲染、更新、卸载等一些列过程，我们将其称之为vue的生命周期。</p>
<span id="more"></span>

<p>下图为官方提供的生命周期图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f52e879eb6444d940ae874c1fb9044~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>生命周期图</p>
<p>了解了生命周期后，我们不难发现，上图中出现了一些生命周期函数，诸如beforeCreate等，稍作整理，最终得出生命周期函数有八种，分别为创建前&#x2F;后，载入前&#x2F;后，更新前&#x2F;后，销毁前&#x2F;后。</p>
<p>1、beforeCreate（创建前）</p>
<p>表示实例完全被创建出来之前，vue 实例的挂载元素$el和数据对象 data 都为 undefined，还未初始化。</p>
<p>2、created（创建后）</p>
<p>数据对象 data 已存在，可以调用 methods 中的方法，操作 data 中的数据，但 dom 未生成，$el 未存在 。</p>
<p>3、beforeMount（挂载前）</p>
<p>vue 实例的 $el 和 data 都已初始化，挂载之前为虚拟的 dom节点，模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中。data.message 未替换。</p>
<p>4、mounted（挂载后）</p>
<p>vue 实例挂载完成，data.message 成功渲染。内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了。实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，DOM 渲染在 mounted 中就已经完成了。</p>
<p>5、beforeUpdate（更新前）</p>
<p>当 data 变化时，会触发beforeUpdate方法 。data 数据尚未和最新的数据保持同步。</p>
<p>6、updated（更新后）</p>
<p>当 data 变化时，会触发 updated 方法。页面和 data 数据已经保持同步了。</p>
<p>7、beforeDestory（销毁前）</p>
<p>组件销毁之前调用 ，在这一步，实例仍然完全可用。</p>
<p>8、destoryed（销毁后）</p>
<p>组件销毁之后调用，对 data 的改变不会再触发周期函数，vue 实例已解除事件监听和 dom绑定，但 dom 结构依然存在。</p>
<p>链接：<a href="https://juejin.cn/post/7082443530588815374">https://juejin.cn/post/7082443530588815374</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>axios的基本使用</title>
    <url>/2022/04/04/axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a>什么是axios</h3><p>axios 是一个基于<a href="https://link.juejin.cn/?target=https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020">Promise</a>的  用于浏览器和 nodejs 的 HTTP 客户端。简单的理解就是ajax的封装。他有一下这些特点：</p>
<span id="more"></span>

<ul>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 <a href="https://link.juejin.cn/?target=https://so.csdn.net/so/search?q=node&spm=1001.2101.3001.7020">node</a>.js 发出 http 请求</li>
<li>支持 Promise <a href="https://link.juejin.cn/?target=https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020">API</a></li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止 CSRF&#x2F;XSRF</li>
</ul>
<p>axios是vue开发中进行网络模块开发时的第一选择。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed554f11cab245c38cb386672558f177~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h3 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/010b5712b9df4e6c8ad30776ec65283c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>请求方式</p>
<p>我们以axios.(config)请求为例来进行说明。首先先下载axios框架（npm install），然后在文件中（例如main.js）中引入axios，之后就可以在该文件中进行请求的发起。axios是支持promise的，故可以在axios.(config)后直接使用.then函数（成功收到数据后的操作）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  url:&#x27;&#x27;,</span><br><span class="line">//默认情况下是get请求，若需要设置，则设置method属性</span><br><span class="line"> method:&#x27;post&#x27;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，如果嫌设置method麻烦的话，也可以直接使用axios.get()、axios.post()</p>
<h3 id="axios处理并发操作"><a href="#axios处理并发操作" class="headerlink" title="axios处理并发操作"></a>axios处理并发操作</h3><p>axios处理并发操作的方式是axios.all()请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url:&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">  url:&#x27;http://123.207.32.32:8000/home/data&#x27;,</span><br><span class="line">  params:&#123;</span><br><span class="line">    type:&#x27;sell&#x27;,</span><br><span class="line">    page:5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(results =&gt;&#123;</span><br><span class="line">  console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76280450ab8b431d8231253e42ecf96b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>results内容</p>
<p>最后获得的results是一个数组，我们也可以将这个数组进行进行拆分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url:&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">  url:&#x27;http://123.207.32.32:8000/home/data&#x27;,</span><br><span class="line">  params:&#123;</span><br><span class="line">    type:&#x27;sell&#x27;,</span><br><span class="line">    page:5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread((res1,res2)=&gt;&#123;</span><br><span class="line">  console.log(res1);</span><br><span class="line">  console.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700b8be0c08848359c6852835cd46b5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"><br>链接：<a href="https://juejin.cn/post/7082444446687559717">https://juejin.cn/post/7082444446687559717</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2022/04/04/Vuex/</url>
    <content><![CDATA[<h3 id="什么是Vuex，它是干什么的"><a href="#什么是Vuex，它是干什么的" class="headerlink" title="什么是Vuex，它是干什么的"></a>什么是Vuex，它是干什么的</h3><p>官方解释：他是一个专为Vue.js应用程序开发的<strong>状态管理模式</strong>，它采用<strong>集中式存储管理</strong>应用所有组件的状态，Vuex是响应式的。</p>
<span id="more"></span>

<h4 id="状态管理是什么"><a href="#状态管理是什么" class="headerlink" title="状态管理是什么"></a>状态管理是什么</h4><p>简单的来说，就是把需要多个组件共享的变量全部存储在一个对象之中，然后将该对象放入顶层的Vue实例之中，供其它组件使用，当然我们也可以手动声明一个共享对象然后将它嵌入每一个组件中，实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const shareThing=&#123;   &#125;</span><br><span class="line">Vue.prototype.shareThing = shareThing //通过Vue原型对每一个Vue实例中的组件进行赋值，在每个组件内部只需要通过this.sharThing.  即可访问shareThing中的具体值，但该方式不支持响应式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>一般来说，用户的登录信息、头像、商品信息等状态信息需要供多个组件共享使用，而这些状态就可以放入Vuex进行响应式管理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9bee50919a4455eb4ce1b6c2890ed74~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h2 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h2><p>我们实现一个计数器，同时实现两个组件共享一个counter属性</p>
<ul>
<li>思路一：通过父子组件传值实现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;counter&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default (&#123;</span><br><span class="line">    name:&#x27;vuex&#x27;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        counter:Number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;counter&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;counter++&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;counter--&quot;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;vuex :counter=&#x27;counter&#x27;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import vuex from &#x27;./components/vuex.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      counter:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">  vuex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>思路二：通过vuex集中管理：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vuex配置文件</span><br><span class="line">// 导入</span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">// 安装插件</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">// 创建对象</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    // 保存状态</span><br><span class="line">    state:&#123;</span><br><span class="line">        counter:100</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    modules:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 导出store</span><br><span class="line">export default store</span><br><span class="line"></span><br><span class="line">//在main.js中引用</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  store,</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line">//类似于router，在这里实现了对每个组件注册$store属性，$store = store</span><br><span class="line"></span><br><span class="line">//在组件中应用</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;$store.state.counter++&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;$store.state.counter--&quot;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;vuex/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59e7d6ee405445a4a4cd724502dc6a2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>action部分处理异步操作，mutations中处理同步操作，Devtools可以追踪哪个组件对state进行了修改</p>
<p>vue官方不推荐直接修改state，而是通过action和mutation对state的具体值进行修改。</p>
<p>vue官方提供了一个插件devtools，用于追踪Vuex中状态的变化，需要在浏览器中自行添加扩展插件。</p>
<p>回到之前的情景，我们不直接调用$store.state.counter来对状态中的counter的值进行更改，而是通过在配置文件中注册mutations方法，来对state中的counter进行修改，然后在每个组件中调用mutations中声明的方法。mutations中的方法都是<strong>同步方法</strong>，如果是异步操作的话，devtools将无法追踪到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置文件   </span><br><span class="line"> mutations:&#123;</span><br><span class="line">        incerement(state)&#123;</span><br><span class="line">            state.counter++</span><br><span class="line">        &#125;,</span><br><span class="line">        decerement(state)&#123;</span><br><span class="line">            state.counter--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//组件调用方法</span><br><span class="line"> methods:&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">      this.$store.commit(&#x27;incerement&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    sub()&#123;</span><br><span class="line">      this.$store.commit(&#x27;decerement&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/378fec2d7c3346339d57f6359e19f47d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>提交mutation是store（state）更新的唯一方式，通过commit(”)来使用mutation中的回调函数</p>
<p>当我们在mutation中处理数据时需要用到外部传入的数据时（例如上例中我们增加一个按钮，让其实现每按一次counter就是增加5），此时需要我们在使用commit调用回调函数时传入额外参数（payload），实现上述要求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//组件中 </span><br><span class="line">&lt;button @click=&quot;addNum(5)&quot;&gt;+5&lt;/button&gt;</span><br><span class="line"> methods:&#123;</span><br><span class="line">    addNum(number)&#123;</span><br><span class="line">      this.$store.commit(&#x27;incerementNum&#x27;,number)</span><br><span class="line">    &#125;</span><br><span class="line">//store文件中</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        incerementNum(state,number)&#123;</span><br><span class="line">            state.counter += number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然除了直接使用commit进行提交，官方还提供了另外一种提交封装，一个包含type属性的对象，我们以上述例子为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//组件中    </span><br><span class="line">addNum(number)&#123;</span><br><span class="line">      // 1.简单的提交封装</span><br><span class="line">      // this.$store.commit(&#x27;incerementNum&#x27;,number)</span><br><span class="line">      // 2.另一种提交封装</span><br><span class="line">      this.$store.commit(&#123;</span><br><span class="line">        type:&#x27;incerementNum&#x27;,</span><br><span class="line">        payload</span><br><span class="line">        // payload是一个对象，内部属性为type:&#x27;incerementNum&#x27;和number:</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">//store文件中</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        incerementNum(state,payload)&#123;</span><br><span class="line">            state.counter += payload.number</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Mutation中的处理方式是将整个commit的对象作为payload进行使用。</p>
<p>当然，我们还可以对Mutation中的函数进行一定处理，以便于导入调用</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de00a7b44bda485388412bb8bf1ea348~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aa350ddc9b743ce9608104ce4c49e7d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h3 id="Mutation的响应式原理"><a href="#Mutation的响应式原理" class="headerlink" title="Mutation的响应式原理"></a>Mutation的响应式原理</h3><p>从先前的state学习中得知，state是响应式的（当state中的数据发生改变时，Vue组件将会自动更新）也就是说，我们申明state中的对象以及其变量时，这些属性都将加入响应式系统中进行实时监听，当属性发生变化时，将会通知界面中所有用到该属性的地方，让界面进行刷新，故我们需要在store中初始化好需要的属性。如果需要改变现有的对象中的属性，可以直接在mutation中声明函数，完成该功能，然后再在组件中使用commit调用即可。当我们需要给state中的对象添加新属性时，方式有：</p>
<ul>
<li><strong>使用Vue.set(obj,’newProp’,value)</strong></li>
</ul>
<p>值得注意的是，state中的属性如果要加入响应式系统的话，必须提前初始化，或使用上方方法增加属性。若单纯使用js已有的在对象中添加属性的方法(state.xxxx[‘xxx’]&#x3D;’xx’)，则添加的属性xx不会加入响应式系统，不会被实时监听，但如果检查属性的话会发现能够实现属性的增加，但由于界面不会随之刷新，故使用该方式添加属性没有实质作用。 相应的，正确的添加方法为：Vue.set(xxxx,’xxx’,’xx’)</p>
<p>同样的，如果我们想要删除某个属性，直接使用js中已有的方法delete（delete state.xxxx.xxx）,也无法实现在响应式系统中的删除。相应的，<strong>Vue.delete(state.xxxx,’xxx’</strong>)可以实现</p>
<h3 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h3><p>单一状态树（single source of truth）指的是将所有的状态(state)全部保存在一个系统中，即将所有的需要进行管理的state全部保存在一个store对象里，而不是分别存于store1、store2等。如此操作有助于今后的管理与维护。</p>
<p>采用单一状态树，可以让我们以最直接的方式找到某个状态的片段</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>getters，类似于computed属性，用于计算state中的值，一般用于呈现state中的值经过处理后的值，操作方式与computed基本类似。</p>
<p>值得一提的是，当需要使用已经在getters中定义过的值时，只需要在后续传参时传入getters，然后通过调用getters.来实现对其中值的访问(第二个传入的参数无论名称都默认为是传入getters)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">       counterPower(state)&#123;</span><br><span class="line">       return state.count* state.count</span><br><span class="line">       &#125;,</span><br><span class="line">       fitPeople(state)&#123;</span><br><span class="line">       return state.People.filter(s =&gt; s.age&gt;=20)</span><br><span class="line">       &#125;,</span><br><span class="line">       fitPeopleLength(state, getters)&#123;</span><br><span class="line">       return getters.fitPeople.length</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>回到上例，当我们想从外部传入数据而不是在内部写死筛选年龄不小于20的人时，我们需要对getters内部传入的数值进行更改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fitPeople(state)&#123;</span><br><span class="line">//返回一个函数后，便可以传入参数，调用该函数</span><br><span class="line">         return function(age)&#123;</span><br><span class="line">             return state.People.filter(s =&gt; s.age&gt;=age)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用箭头函数对上方函数进行进一步简化得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fitPeople(state)&#123;</span><br><span class="line">//返回一个函数后，便可以传入参数，调用该函数</span><br><span class="line">         return age =&gt; &#123;</span><br><span class="line">             return state.People.filter(s =&gt; s.age&gt;=age)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>mutations中的方法全是同步操作，如果出现异步操作的话，devtools将无法实现跟踪，很难去debug,此时需要使用action(异步操作）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31d404a2dbc43da963464f0cc55cec2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>值得注意的是，在action中并不是直接对state中进行更改，而是通过commit使用mutation中的函数对state进行修改（这样操作才能让devtools实现正常追踪）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea32cd3a82549bfb7f726902d18f5d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>Vuex工作流程</p>
<p>action的使用方式与mutation差不多，使用this.$store.dispatch调用在action中已声明好的函数。值得注意的是，在action中不能直接对state中的属性或对象进行更改，而是调用mutation中的方法进行更改，具体案例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //配置文件 </span><br><span class="line"> mutations:&#123;</span><br><span class="line">        updateState(state)&#123;</span><br><span class="line">            state.People[1].name = &#x27;sunShineBoy&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        // context上下文</span><br><span class="line">        aUpdateState(context, payload)&#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                context.commit(&#x27;updateState&#x27;);</span><br><span class="line">                console.log(payload);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//组件</span><br><span class="line">  methods:&#123;</span><br><span class="line"></span><br><span class="line">    aUpdateState()&#123;</span><br><span class="line">      this.$store.dispatch(&#x27;aUpdateState&#x27;,&#x27;我是sunshine boy&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，如果我们需要在异步处理完成后提醒用户已经完成异步处理的话，我们可以在dispatch传入数据时进行更改(传入一个大的对象)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//组件</span><br><span class="line">aUpdateState()&#123;</span><br><span class="line">      this.$store.dispatch(&#x27;aUpdateState&#x27;,&#123;</span><br><span class="line">        msg:&#x27;我是sunshine boy&#x27;,</span><br><span class="line">        success:()=&gt;&#123;</span><br><span class="line">          console.log(&#x27;我终于成为阳光男孩辣&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">//配置文件</span><br><span class="line">aUpdateState(context, payload)&#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                context.commit(&#x27;updateState&#x27;);</span><br><span class="line">                console.log(payload.msg);</span><br><span class="line">                payload.success();</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然上述操作还可以通过Promise进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置文件        </span><br><span class="line">aUpdateState(context, payload)&#123;</span><br><span class="line">            return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">               setTimeout(() =&gt; &#123;</span><br><span class="line">                context.commit(&#x27;updateState&#x27;);</span><br><span class="line">                resovle(&#x27;传入的数据&#x27;)</span><br><span class="line">            &#125;, 1000); </span><br><span class="line">            &#125;)    </span><br><span class="line">        &#125;</span><br><span class="line">//组件</span><br><span class="line"> aUpdateState()&#123;</span><br><span class="line">      this.$store.dispatch(&#x27;aUpdateState&#x27;,&#x27;我是sunshine boy&#x27;)</span><br><span class="line">      .then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;我是阳光大男孩辣！&#x27;);</span><br><span class="line">        console.log(res);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>action这个方法本身就可以返回一个Promise,在返回这个promise之后就可以在其他地方（例如dispatch中）拿到这个promise，然后在后端就可以就这加上.then等</p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab2f8a8a86c0458286e403abd00cf8dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>模块化</p>
<p>modules的核心就是模块化，将复杂的应用进行抽离，抽离出若干个小模块，并分别进行管理，如上图，若要访问定义的moduleA的状态，则需要通过this.store.state.a来进行访问（这里的a是在modules中注册的名字），如果要使用声明的modules中的mutation，s还是直接在组件中使用commit，需要注意的是，∗∗各个模块间声明的mutations中的方法名不要重合∗∗。外部调用commit后，会首先在store中的mutations中进行方法的寻找，未果，再在各个模块进行寻找。getters和mutations相同，也是直接在外部调用store.state.a来进行访问（这里的a是在modules中注册的名字），如果要使用声明的modules中的mutation，s还是直接在组件中使用commit，需要注意的是，<strong>各个模块间声明的mutations中的方法名不要重合</strong>。外部调用commit后，会首先在store中的mutations中进行方法的寻找，未果，再在各个模块进行寻找。getters和mutations相同，也是直接在外部调用store.state.a来进行访问（这里的a是在modules中注册的名字），如果要使用声明的modules中的mutation，s还是直接在组件中使用commit，需要注意的是，∗∗各个模块间声明的mutations中的方法名不要重合∗∗。外部调用commit后，会首先在store中的mutations中进行方法的寻找，未果，再在各个模块进行寻找。getters和mutations相同，也是直接在外部调用store.getters即可。</p>
<p>如果想要在module中使用根(即store)的一些状态的话，只需要在传输参数的时候传入rootState.需要注意的是，模块在声明actions中的异步操作函数时使用commit，只能调用该模块中mutations中已声明的函数方法。在actions中的方法，我们会传入参数context(上下文)，我们打印一下这个参数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cb6203cbdb84a619b62e3853d6397cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>不难看出context中不仅包含该模块的getters和state还包含根中的getters和state，故需要访问根中的getters和state只需要通过context.rootGetters或者context.rootState即可进行访问,当然在这里也可以对对象context进行解构，传入context中所包含的并且我们所需要的参数。</p>
<ul>
<li>ps.只有在模块里面才会有根的概念</li>
</ul>
<p>链接：<a href="https://juejin.cn/post/7082442359216013326">https://juejin.cn/post/7082442359216013326</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router</title>
    <url>/2022/04/04/vue-router/</url>
    <content><![CDATA[<p>前置知识：</p>
<h4 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h4><p>所谓路由（routing）就是通过互联网的网络把信息从原地址传输到目的地址的活动（说了，但没完全说）。</p>
<span id="more"></span>

<h4 id="后端渲染与后端路由"><a href="#后端渲染与后端路由" class="headerlink" title="后端渲染与后端路由"></a>后端渲染与后端路由</h4><p>后端渲染，指的是使用jsp（通过java代码实现从数据库中读取数据，并动态的放在页面中）、php等技术使得需要最终呈现的页面在服务器端实现，然后上传至客户端（区别于ajax）</p>
<p>后端路由，指的是后端处理url和页面之间的映射关系，最后将指定的页面在客户端呈现的过程，后端路由的缺点显而易见，最主要的是不便于前端人员对代码进行维护以及将html代码与数据、逻辑相混杂，不便于编写和维护。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/220a55b3729347da81b7d4a5e4bfaf70~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><p>前端路由是实现单页面富应用的关键，所谓单页面富应用指的是在静态内容数据库只有一个html文件（区别于后端路由的每个页面一个html文件），而具体展示的内容是通过传入的js文件决定的。每一个显示逻辑（比如展示首页、联系页面）都有一个相对的url(如xxx&#x2F;home xxx&#x2F;men),前端路由就是通过改变url来改变展示内容，同时前端路由通过一些方式实现改变url而不刷新页面，从而实现单页面富应用。</p>
<h3 id="改变url但不刷新页面的方式"><a href="#改变url但不刷新页面的方式" class="headerlink" title="改变url但不刷新页面的方式"></a>改变url但不刷新页面的方式</h3><p>改变url但不刷新的方式有两个，分别为改变url的hash以及使用html5的history</p>
<ul>
<li>url的hash：改变url的hash值可以做到不刷新而改变页面内容，具体操作方式： location.hash &#x3D; ‘ (url) ‘</li>
<li>html5的history：具体操作方式：history.pushState &#x3D; ‘ ({}，’ ‘ , ‘(url)’) ‘ （将新的url压栈，可以返回） 返回上一个：history.back() 返回下一个： history.forward() history.replaceState &#x3D;({},”,’(url)’) (将新的url替换旧的url，不可返回) history.go(数值) （返回到 该数值 个url）</li>
<li><strong>vue-router中的纯代码实现</strong>：使用方法 组件.router.push(‘url’);组件.router.push(‘url’); 组件.router.push(‘url’);组件.router.replace(‘url’)</li>
</ul>
<h3 id="vue-router安装与使用"><a href="#vue-router安装与使用" class="headerlink" title="vue-router安装与使用"></a>vue-router安装与使用</h3><p>通过脚手架生成项目时圈选即可，或者在终端输入命令：npm install vue-router –save 进行安装</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc4ecaa5efd4741b2ef071d6ae14516~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>Vue在安装插件的时候都需要使用Vue.use(插件)来进行安装</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01158eb901794e2a985f0d57bd9565eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>对router文件夹中的index.js文件进行配置</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/906cfcc185ca4f12a5a3358730501414~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>在main.js文件中引入router</p>
<p>至此，路由的底层框架已经搭建完毕了。接下来对vue-router进行配置使用</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8b8d96f61a3442d90f18933a18423b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>router文件配置如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">import Home from &#x27;../views/Home.vue&#x27;</span><br><span class="line"></span><br><span class="line">//导入组件</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">//安装vue-router</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/&#x27;,</span><br><span class="line">    // redirect重定向（设定默认首页）</span><br><span class="line">    redirect:&#x27;/home&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    name: &#x27;About&#x27;,</span><br><span class="line">    // route level code-splitting</span><br><span class="line">    // this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    // which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//分配url与组件</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//生成router</span><br><span class="line">export default router</span><br><span class="line">//导出</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最后在app.vue中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt; |</span><br><span class="line">      &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//&lt;router-link/&gt;最终渲染出来为超链接（a标签）</span><br><span class="line">//&lt;router-view/&gt;用于站位，即组件位置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>url默认为哈希模式，如果想要将url改为history模式（将会去除#），只需要在生成router时添加一个属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode:&#x27;history&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="router-link的其他属性"><a href="#router-link的其他属性" class="headerlink" title="router-link的其他属性"></a>router-link的其他属性</h3><ul>
<li>tag:router-link默认渲染为a标签，通过附加tag属性可以改变router-link渲染的标签，例如tag&#x3D;”button”</li>
<li>relpace:history模式下改变url默认使用pushState，通过添加replace改变url的变化方式，即使用replaceState对url进行更改，直接添加replace即可。</li>
<li>active-class:点击router-link后，会自动增加两个类，通过添加active-class属性改变增加类地名称，例如 active-class&#x3D;’active’;当然，如果要改变所有的router-link可以在路由配置文件（index.js）中生成router处添加属性linkActiveClass:’ ‘</li>
</ul>
<h3 id="动态路由的使用"><a href="#动态路由的使用" class="headerlink" title="动态路由的使用"></a>动态路由的使用</h3><p>我们以生成用户界面为例，现在路由配置文件中进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/user/:userId&#x27;,</span><br><span class="line">// 使用语法糖绑定userId</span><br><span class="line">    component:User</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后再在App.vue中绑定router-link</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;router-link :to=&#x27;&quot;/user/&quot;+userId&#x27;&gt;user&lt;/router-link&gt;</span><br><span class="line">//使用v-bind将data中的userId绑定进入url之中</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default (&#123;</span><br><span class="line">  name:&#x27;App&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      userId:&#x27;bovi&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>至此就实现了点击user跳转至user&#x2F;bovi，同时路由跳转至显示user组件，如果需要实现在user页面中实时显示跳转的userid，则需要在user.vue文件中使用$route</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是用户界面&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;UserId&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;$route.params.userId&#125;&#125;&lt;/p&gt;</span><br><span class="line">// $route指向处于活跃的路由 params:参数（parameters）userId:这里的名称取决于路由配置文件中使用语法糖绑定的属性的名称</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default(&#123;</span><br><span class="line">    name:&#x27;user&#x27;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        UserId() &#123;</span><br><span class="line">            return this.$route.params.userId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c76b1ccfdc94a75bcb6f4edc10d6f7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>最终效果图</p>
<h3 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h3><p>我们在使用构建项目时，会发现最后生成的dist文件中会将css文件和js文件进行分包，其中js文件夹中会有三个文件app.<strong><em>*.js(当前应用程序开发的所有代码)\manifest.*</em>*.js（给打包的代码做底层支撑）&#x2F;vendor.*</strong>.js（第三方代码，例如vue&#x2F;vue-router&#x2F;axios）,但是打包后的文件还是很大（尤其是app.js），如果将所有的路由的对应的js代码放入app.js中，会导致加载缓慢的问题，为了解决这个问题，我们将各个路由对应的js代码单独分离出来，使用懒加载的模式（用到才加载）对整个页面加载进行优化。</p>
<p>路由懒加载实现了将各个路由对应的组件打包成为一个个晓得js代码块，只有在这个路由被访问到是，才加载相应的组件，而不是一次性全部加载。</p>
<p>懒加载的实现方式：（在配置路由的文件中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    name: &#x27;About&#x27;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () =&gt; import(&#x27;../views/About.vue&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aada30209ac429d8bc8ec7a19bdbbe2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67219e502724c7f898f9ca84833d04b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>嵌套路由非常常见，例如 &#x2F;home&#x2F;page1就是一个路由嵌套，一个路由映射一个组件，访问嵌套路由将会将涉及到的组件分别进行访问。实现嵌套路由的步骤很简单：1.创建相对应的子组件，并在路由配置文件中配置对应的子路由；2.在组件内部使用<router-view>标签</router-view></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置路由配置文件</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/Home.vue&#x27;),</span><br><span class="line">//子路由配置，在children数组中进行注册</span><br><span class="line">    children:[</span><br><span class="line">      &#123;</span><br><span class="line">        path:&#x27;news&#x27;,</span><br><span class="line">        component :()=&gt;import(&#x27;../views/HomeNews&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br><span class="line">//子路由对应组件在父路由对应组件中的引入</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/home/news&quot; tag=&quot;button&quot;&gt;点我康好康的！！&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>当我们点击路由后进行页面跳转，此时我们希望传输一些数据（例如userId）到新界面并予以使用、呈现时，就需要用到参数传递。</p>
<p>传递参数主要由两种方式：params和query</p>
<ul>
<li>params:配置路由格式：&#x2F;router&#x2F;:id 传递方式：在path后面跟上相对应的值(修改app.vue中to的url） 传递后形成的路径：&#x2F;router&#x2F;bovi</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由配置文件</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/user/:userId&#x27;,</span><br><span class="line">    component:User</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line">//app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;router-link :to=&#x27;&quot;/user/&quot;+userId&#x27;&gt;user&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default (&#123;</span><br><span class="line">  name:&#x27;App&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      userId:&#x27;bovi&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//vue.app中传入的部分</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是用户界面&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;UserId&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;$route.params.userId&#125;&#125;&lt;/p&gt;</span><br><span class="line">//两者等价</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default(&#123;</span><br><span class="line">    name:&#x27;user&#x27;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        UserId() &#123;</span><br><span class="line">            return this.$route.params.userId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c7b86ce8fc4d9fb9e021f1d63452c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>最后呈现结果</p>
<ul>
<li>query:配置路由格式：&#x2F;router（普通配置格式） 传递方式：在对象中使用<strong>query中的key作为传递方式</strong> 传递后生成的路径：&#x2F;router?id&#x3D;bovi 使用query的原理：通过修改url中的query部分实现路由后缀跳转 <strong>url:协议(scheme):&#x2F;&#x2F;主机(host)：端口(port)&#x2F;路径(path)？查询（query）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//app.vue文件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;!-- url:协议(scheme)://主机(host)：端口(port)/路径(path)？查询（query） --&gt;</span><br><span class="line">      &lt;router-link :to=&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;bovi&#x27;,height:&#x27;1.92&#x27;&#125;&#125;&quot;&gt;profile&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">//路由配置文件</span><br><span class="line">const routes = [</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/profile&#x27;,</span><br><span class="line">    component:() =&gt; import(&#x27;../views/profile.vue&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">//profile.vue呈现</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;这个是&#123;&#123;$route.query.name&#125;&#125;的档案&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;他的身高是&#123;&#123;$route.query.height&#125;&#125;米&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，跳转路由可以使用万能的方法：注册事件，绑定事件，事件内部为this.router.push()&#x2F;this.router.push()&#x2F;this.router.push()&#x2F;this.router.replace()，括号内的东西和:to括号中的东西相同</p>
<h3 id="router与route"><a href="#router与route" class="headerlink" title="router与route"></a>router与route</h3><p>方前使用了很多次router以及route，但是这两个东西到底是怎么生成的呢？他们两个又有什么区别呢？</p>
<p>我们在main.js中对router进行打印，不难发现router其实就是路由配置文件中导出的有一个VueRouter实例,查阅源码不难得出这个VueRouter是一个类，其中内置了诸如push()、replace()等函数，同时$router与最后在main.js中传入的router是同一个东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  mode:&#x27;history&#x27;,</span><br><span class="line">  linkActiveClass:&#x27;active&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca15c661ae8247769c5ac8b65015be55~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>router具体信息</p>
<p>而route就是当前处于激活状态（active）的路由对应的信息</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f67085850144bb0a4347ea8e6b0f29d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>route具体信息</p>
<p>当然，在使用的时候，除了在main.js中不需要加$，其余地方都需要加，因为所有的组件都继承自Vue类的原型</p>
<h3 id="全局导航守卫-router的watch函数）"><a href="#全局导航守卫-router的watch函数）" class="headerlink" title="全局导航守卫(router的watch函数）"></a>全局导航守卫(router的watch函数）</h3><p>当我们在路由跳转的时候想要监听并作出相应动作（如实时将网页标题改为当前路由名称）时，就需要用到全局导航守卫，具体使用：在路由配置文件进行事件注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由配置文件</span><br><span class="line">const routes = [</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path:&#x27;/profile&#x27;,</span><br><span class="line">    component:() =&gt; import(&#x27;../views/profile.vue&#x27;),</span><br><span class="line">    meta:&#123;</span><br><span class="line">      title:&#x27;profile&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">//注册元数据（在元数据中在增加路由的其他属性）</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">  //从from到to</span><br><span class="line">  document.title = to.meta.title;</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其中，beforeEach函数(前置守卫函数、跳转之前调用)中的参数是一个函数，该函数有三个参数分别是 to、from、next，其中to和from都是一个路由（route），且切换路径是从from到to，而next又是另一个函数，且必须要调用（让整个程序继续进行，），在上述例子中，如遇到路由嵌套，标题将会变为undifined，因为此时的路由to中没有对应的title属性，此时需要使用另一个数组属性matched，他包括了嵌套的所有路由的信息，并从外到内排序，故将document.title&#x3D; to.meta.title改为document.title &#x3D; to.matched[0].meta.title，即可</p>
<p>当然在这个场景中也可以调用afterEach函数（后置守卫函数、跳转至后调用），同样的该函数有三个参数，分别是 to、from、next。后置守卫函数不需要主动调用next函数。</p>
<p>以上两个守卫函数成为全局守卫，当然，守卫中还有路由专享守卫（在路由配置中直接定义–const routers &#x3D;[]中）、组件内守卫(beforRouteEnter（）、beforeRouteUpate()、beaforeRouteLeave()),具体内容可查询<a href="https://link.juejin.cn/?target=https://router.vuejs.org/zh/guide/advanced/navigation-guards.html%23%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">导航守卫 | Vue Router (vuejs.org)</a>。</p>
<h3 id="与keep-alive的邂逅"><a href="#与keep-alive的邂逅" class="headerlink" title="与keep-alive的邂逅"></a>与keep-alive的邂逅</h3><h4 id="什么是keep-alive"><a href="#什么是keep-alive" class="headerlink" title="什么是keep-alive"></a>什么是keep-alive</h4><p>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b26040410644353b68f2e8d289ea9e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>vue的生命周期</p>
<p>当我们切换路由的时候，被切换的路由对应的组件将会被摧毁（destroy），而切换到的路由的组件就会生成（create），而有些组件我们不希望它被重复的摧毁生成，此时需要用到keep-alive标签，只需要将保持不变的内容放入标签内即可。值得一提的是Vue生命周期中的activated(激活）和deactivated(未激活）函数只有在keep-alive中标签中才是有效的（等同于不在keep-alive标签中使用created和destroyed函数）</p>
<h3 id="keep-alive中的重要属性"><a href="#keep-alive中的重要属性" class="headerlink" title="keep-alive中的重要属性"></a>keep-alive中的重要属性</h3><ul>
<li>include:字符或者正则表达式，字符间用逗号隔开，只有匹配的组件才会被缓存（匹配name属性）</li>
<li>exclude:字符或者正则表达式，字符间用逗号隔开，任何匹配的组件都不会被缓存（匹配name属性）</li>
</ul>
<p>链接：<a href="https://juejin.cn/post/7082441639100153893">https://juejin.cn/post/7082441639100153893</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli</title>
    <url>/2022/04/04/Vue-cli/</url>
    <content><![CDATA[<p>Cli（Command-Line interface），即命令行界面，俗称脚手架，大型的前端开发框架如react、vue都有自己的官方CLI，CLI可以帮助开发者搭建开发环境并且配置webpack。</p>
<span id="more"></span>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53cac3881083494f94972eaf4a577f9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>传统意义上的脚手架</p>
<p>cli需要对webpack进行配置，而webpack是基于node.js的一个工具，故CLI需要依赖node.js</p>
<h4 id="CLI的安装"><a href="#CLI的安装" class="headerlink" title="CLI的安装"></a>CLI的安装</h4><p>以vue举例，目前脚手架默认为Vue CLI3,安装命令如下（在已经安装node.js和webpack的前提下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g@vue/cli</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>安装完脚手架便可以着手搭建项目框架了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue create &lt;项目名称&gt; //vue-cli 3创建项目</span><br><span class="line">vue init &lt;项目名称&gt;   //vue-cli 2创建项目</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>eslint的使用：在最开始的构建中可以选择是否使用eslint；在config文件夹中的index.js中找到useEslint,将其值设置为false便可关闭</p>
<h3 id="runtime-compiler-与-runtimeonly"><a href="#runtime-compiler-与-runtimeonly" class="headerlink" title="runtime+compiler 与 runtimeonly"></a>runtime+compiler 与 runtimeonly</h3><p>vue的实际运行过程如下图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00c7f3a467c944bdbb0fd7ad88a54227~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"> 使用runtime+compiler将会完整的走完template-&gt;ast-&gt;render-&gt;virtual dom-&gt;ui 而使用runtimeonly只进行render-&gt;virtual dom-&gt;ui操作，他们的唯一区别就是main.js函数</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f6b5b0007d44f139bcb3b21a9106cb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p>
<p>runtimeonly相对于runtime+compiler更加轻量、效率也更高。其中render:h&#x3D;&gt;h(App)，等价于render:function(h){return h(App)}</p>
<p>h相当于是createElement,使用该函数相当于生成了一个组件，通过该方法，使最终挂载的</p>
<p>替换为createElement生成内容</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86f4522d8da4205b9189693522d233e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>之所以可以直接使用render函数，是因为之前传入的组件App已经经过编译，内部不存在template。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4923124ef53444f8901c7f071fe8c83d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>console.log(App)后的结果</p>
<p>而之前的.vue文件是由先前安装好的vue-template-compiler解析成render函数(vue-loader用于加载.vue文件、vue-template-compiler用于解析.vue文件).</p>
<h3 id="Vue-CLI2-VS-Vue-CLI3"><a href="#Vue-CLI2-VS-Vue-CLI3" class="headerlink" title="Vue CLI2 VS Vue CLI3"></a>Vue CLI2 VS Vue CLI3</h3><p>3.x版本的脚手架相较于2.x版本，文件目录更加简洁，删除了配置文件的文件夹，取而代之的是通过可视化编辑，通过命令 vue ui唤出可视化编辑端</p>
<p><img src="/2022/04/04/Vue-cli/" alt="img"></p>
<p>可以通过Vue项目管理器对项目进行配置的改变、以及创建新的项目。我们导入已经创建好了的项目</p>
<p><img src="/2022/04/04/Vue-cli/" alt="img"></p>
<p>在仪表盘的左侧可以查看与管理插件、依赖、配置，也可以才这里添加所需要的依赖、插件、配置。如果想要修改其他配置，可以在最高层文件夹中添加vue.config.js文件，并在其中进行配置的填写。</p>
<p>作者：captainbovi<br>链接：<a href="https://juejin.cn/post/7082439623300874248">https://juejin.cn/post/7082439623300874248</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>es6模块化导入导出</title>
    <url>/2022/04/04/es6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>模块化，能够有效的提高多人开发时的效率，同时避免出现全局变量命名重复等比较严重的问题。常见的模块化导入导出的规范有：CommonJS、AMD、CMD、ES6的modules规范，其中只有ES6的模块规范不需要底层支持就可以直接在浏览器中运行。这里使用ES6的规范进行模块化导入导出</p>
<span id="more"></span>

<p>先生成一个html文件，再生成三个(数量不限，这里用3个进行示范)js文件（man.js、we.js、woman.js），先对该JS文件进行引用，这里需要对引用的JS文件设置type属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- type=&quot;module&quot; 即将整个引用的js文件视作一个封闭的模块 --&gt;</span><br><span class="line">&lt;!-- 使用import导入的时候需要在html文件中将引入的JS文件将类型设置为module--&gt;</span><br><span class="line">&lt;!-- 一个模块的内部的数据封闭的，一个模块就是一个作用域  --&gt;</span><br><span class="line">    &lt;script src=&quot;man.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;woman.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;we.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们不妨在man.js中设置一些变量和函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &#x27;bovi&#x27;;</span><br><span class="line">let age = 19;</span><br><span class="line">let flag = true;</span><br><span class="line"></span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再对woman.js 中设置一些变量和函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name =&#x27;Fbovi&#x27;;</span><br><span class="line">let age = 20;</span><br><span class="line">let flag = false;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再在we.js中设置一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(flag)&#123;</span><br><span class="line">    console.log(12);</span><br><span class="line">    console.log(sum(20,200));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>不难看出woman.js和man.js中存在命名相同的变量，但由于在引入的时候设置了type&#x3D;’module’，将两个文件模块化，从而不会出现报错</p>
<p>此时我们想要在we.js使用man.js中的变量flag以及函数sum。首先需要对flag、sum进行导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导出方式一：以对象的方式导出</span><br><span class="line">export&#123;</span><br><span class="line">    flag,sum</span><br><span class="line">&#125;</span><br><span class="line">// 导出方式二：</span><br><span class="line">export var flag = true;</span><br><span class="line">// 导出方式三：导出类 /函数</span><br><span class="line">export function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在man.js文件中实现导出后，我们需要在we.js中进行导入,需要注意的是，我们在导入&#x2F;使用导入的变量或函数时，必须使用他们的原名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//导入方式</span><br><span class="line">import &#123; flag，sum &#125; from &quot;./man&quot;;</span><br><span class="line">// 统一全部导入 将一个模块中导出的全部属性、函数放入一个对象mess(名称可更改)</span><br><span class="line">// import * as mess from &#x27;./man.js&#x27;</span><br><span class="line">// console.log(mess.flag)；</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，如果想要让导出者对导入的变量、函数进行命名的话，我们在导出的时候需要使用export default</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// export default（一个模块中只能有一个），可以导出属性或者函数 </span><br><span class="line">const address = &#x27;成都&#x27;;</span><br><span class="line">export default address;</span><br><span class="line">export default function(message)&#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;</span><br><span class="line">// 导入  import aaaa from &#x27;./man.js&#x27;  其中aaaa可以为任意字符名字,此时aaaa = &#x27;成都&#x27;</span><br><span class="line">// 导入  import aaaa from &#x27;./man.js&#x27;  aaaa(&quot;你好呀&quot;),将会实现在控制台输出 你好呀 ；其中aaaa可以为任意字符名字</span><br></pre></td></tr></table></figure>


<p>链接：<a href="https://juejin.cn/post/7082438093613039653">https://juejin.cn/post/7082438093613039653</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>slot介绍与应用</title>
    <url>/2022/04/04/slot%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="什么是slot、插槽的基本使用"><a href="#什么是slot、插槽的基本使用" class="headerlink" title="什么是slot、插槽的基本使用"></a>什么是slot、插槽的基本使用</h4><p>slot，即插槽，是为了提高组件复用性而孕育的标签，在组件模板中添加，可以预留位置，用于后续的补充替换，实现一个组件，多个表现样式，极大提升组件的复用性。</p>
<span id="more"></span>

<p>具体操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是一个组件&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;你全家都是组件&lt;/p&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt; </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;p&gt;上面的也叫组件&lt;/p&gt; &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;p&gt;上面好像是组件&lt;/p&gt; &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01455dbb048746c99c5b1bc9b82badd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>当然，slot标签中也可以预设值（即默认值），当你需要改变的时候只需要在外部设置好想要的样式即可自动覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;我是一个组件&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;你全家都是组件&lt;/p&gt;</span><br><span class="line">        &lt;slot&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/slot&gt; </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt;  &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;p&gt;上面的也叫组件&lt;/p&gt; &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;p&gt;上面好像是组件&lt;/p&gt; &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt;  &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果与上图相同</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be524654d26045c1a1755f2cf98cf3a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>当然，如果想要插入插槽的部分由若干个小标签组成，则这些标签将会全部嵌入插槽中</p>
<h4 id="具名插槽的使用"><a href="#具名插槽的使用" class="headerlink" title="具名插槽的使用"></a>具名插槽的使用</h4><p>当然，一个组件中可以有多个插槽，而为了方便区别各个插槽以及插入插槽的样式，我们使用具名插槽进行解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;slot name=&quot;left&quot;&gt; &lt;button&gt;我是第一个的按钮&lt;/button&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;center&quot;&gt; &lt;button&gt;我是中间的按钮&lt;/button&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;right&quot;&gt; &lt;button&gt;我是最后的按钮&lt;/button&gt; &lt;/slot&gt; </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//在想要插入的部门添加属性slot，并附上要插入的插槽的名字</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;button slot=&quot;center&quot;&gt;哈哈&lt;/button&gt; &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1e496bed42d43f6b72f23dc7063e613~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> VUE中有一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在自己作用域内编译</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>作用域插槽主要用于实现 父组件替换插槽的内容，但是内容由子组件来提供</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">            data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                    Languages:[&#x27;Java&#x27;,&#x27;C++&#x27;,&#x27;c#&#x27;,&#x27;Go&#x27;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;) </span><br><span class="line">复制代码</span><br><span class="line">&lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;slot&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for=&quot;item in Languages&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上述例子，如果我想要改变插槽中的样式但是沿用子组件的内容，我们根据作用域可知，不能直接在父组件中写 v-for&#x3D;”item in Languages”，因为此时的作用域是vue实例app，所以v-for将会在app的data属性中查找 Languages 数组，故此刻我们需要使用作用域插槽,使用v-slot语句实现。v-slot <em>：后边是插槽名称</em>，&#x3D;后边是组件内部绑定作用域值的映射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;slot name=&#x27;lis&#x27; :PLanguages=&#x27;Languages&#x27; :Pid=&#x27;id&#x27;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for=&quot;item in Languages&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt; &lt;button slot=&quot;center&quot;&gt;哈哈&lt;/button&gt; &lt;/cpn&gt;</span><br><span class="line">        &lt;cpn v-slot:lis=&#x27;lang&#x27;&gt;</span><br><span class="line">//这里lang是从子组件绑定过来的属性的集合</span><br><span class="line">          &lt;div&gt;&#123;&#123;lang.pid&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;lang.planguages&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;span v-for=&quot;num in lang.pid&quot;&gt;&#123;&#123;num&#125;&#125; &lt;/span&gt;</span><br><span class="line">            &lt;!-- object.join(&#x27;#&#x27;):将数组object转化为字符串，并将每个字符间通过#号（可以更换）相连接 --&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;lang.planguages.join(&#x27;*&#x27;)&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">     const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">            data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                    Languages:[&#x27;Java&#x27;,&#x27;C++&#x27;,&#x27;c#&#x27;,&#x27;Go&#x27;],</span><br><span class="line">                    id:[12,123,441,234]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在模板插槽处绑定的属性（这里为PLanguages、Pid），在父组件中应用时字母全部都会变成小写</p>
<p>链接：<a href="https://juejin.cn/post/7082437661348069406">https://juejin.cn/post/7082437661348069406</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>组件访问</title>
    <url>/2022/04/04/%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>当我们想要实现在父组件上进行操作后访问子组件的功能或者数据时，可以使用 refs或refs 或refs或children 来实现。同样的，先注册一个实例以及一个子组件</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                  name:&#x27;我是傻逼&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                showinfo()&#123;</span><br><span class="line">                    console.log(&#x27;showinfo&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;) </span><br><span class="line">    &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;我是个屑子组件&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;cpn &gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;button @click = &#x27;btnClick&#x27;&gt;访问子组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们在子组件中声明一个函数以及一个数据用于模拟父组件的访问,在父组件中注册一个自定义事件，用于做访问子组件的触发器。接着，在父组件中注册该事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> methods:&#123;</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    //  1.$children 获得一个对象数组（里面装的是所有的子组件）</span><br><span class="line">                      console.log(this.$children);</span><br><span class="line">                     this.$children[0].showinfo();</span><br><span class="line">                     for(let CPN of this.$children)&#123;</span><br><span class="line">                         console.log(CPN.name);</span><br><span class="line">                         CPN.showinfo();</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>children获取的是该父组件的所有子组件，在大部分时间中我们都想要精确的获取其中的某一个子组件，这个时候，我们就需要通过children获取的是该父组件的所有子组件，在大部分时间中我们都想要精确的获取其中的某一个子组件，这个时候，我们就需要通过children获取的是该父组件的所有子组件，在大部分时间中我们都想要精确的获取其中的某一个子组件，这个时候，我们就需要通过refs来进行精确定位了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;cpn ref=&#x27;aaa&#x27;&gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;cpn&gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;button @click = &#x27;btnClick&#x27;&gt;访问子组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">       methods:&#123;</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    // 2. $refs 获得的是一个对象</span><br><span class="line">                    console.log(this.$refs.aaa.name);</span><br><span class="line">                    this.$refs.aaa.showinfo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在希望准确获取的子组件上增加一个ref属性（类似于Key），便可以实现对该组件的访问。值得一提的是，如果出现两个及以上ref属性值相同的子组件，最后通过$refs访问的子组件是第一个。</p>
<p>类似的，想要实现子访父，则通过parent实现。但是不推荐使用子访父：在开发时，若要用子访父，会使子组件的开发受父组件开发的限制、不够独立、复用性不强。特别的，有parent实现。 但是不推荐使用子访父：在开发时，若要用子访父，会使子组件的开发受父组件开发的限制、不够独立、复用性不强。特别的，有parent实现。但是不推荐使用子访父：在开发时，若要用子访父，会使子组件的开发受父组件开发的限制、不够独立、复用性不强。特别的，有root—访问根组件</p>
<p>链接：<a href="https://juejin.cn/post/7082437425108090917">https://juejin.cn/post/7082437425108090917</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>父子组件通信双向绑定</title>
    <url>/2022/04/04/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>将父传子，子传父稍微结合一下，实现父子组件通信双向绑定。最终实现在子组件的输入框中输入数据，实时改变父组件中的数据</p>
<span id="more"></span>

<p>同样的，先注册子组件和父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line"></span><br><span class="line">            props:&#123;</span><br><span class="line">                num1:Number,</span><br><span class="line">                num2:Number</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                number1:1,</span><br><span class="line">                number2:0</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;data:&#123;&#123;num1&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;!-- v-model 等于  :value=&#x27;&#x27;+ @input=&#x27; =$event.target.value&#x27;--&gt;</span><br><span class="line"></span><br><span class="line">            &lt;input type=&quot;text&quot; :value=&#x27;dnumber1&#x27; @input =&#x27;num1Input&#x27;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;data:&#123;&#123;num2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; :value=&#x27;dnumber2&#x27; @input =&#x27;num2Input&#x27;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt; </span><br><span class="line">   &lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">//将父组件中的数据绑定到子组件上   </span><br><span class="line">        &lt;cpn </span><br><span class="line">        :num1=&#x27;number1&#x27;</span><br><span class="line">        :num2=&#x27;number2&#x27;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要注意的是使用:value中不能直接绑定props中的属性，以免出现数据紊乱，故需要在data中重新注册数据，然后对data中的数据进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">            // 避免直接修改props中的值，直接修改可能会导致数据紊乱出错</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    dnumber1:this.num1,</span><br><span class="line">                    dnumber2:this.num2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            props:&#123;</span><br><span class="line">                num1:Number,</span><br><span class="line">                num2:Number</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后子组件中自定义事件，发射给父组件，这里我们把v-model拆开也是为了方便自定义事件( v-model 等于 :value&#x3D;”+ @input&#x3D;’ &#x3D;event.target.value’),故我们将@input&#x3D;’&#x3D;event.target.value’ ),故我们将 @input&#x3D;’ &#x3D;event.target.value’),故我们将@input&#x3D;’&#x3D;event.target.value’ 定义为一个新事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">                num1Input(event)&#123;</span><br><span class="line">                    this.dnumber1 = event.target.value;</span><br><span class="line">                    // 发送事件</span><br><span class="line">                    this.$emit(&#x27;num1change&#x27;,this.dnumber1);</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                num2Input(event)&#123;</span><br><span class="line">                    this.dnumber2 = event.target.value;</span><br><span class="line">                    // 发送事件</span><br><span class="line">                    this.$emit(&#x27;num2change&#x27;,this.dnumber2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;props:&#123;&#123;dnumber1&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;h2&gt;data:&#123;&#123;num1&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;!-- v-model 等于  :value=&#x27;&#x27;+ @input=&#x27; =$event.target.value&#x27;--&gt;</span><br><span class="line">            &lt;!-- &lt;input type=&quot;text&quot; :value=&#x27;dnumber1&#x27; @input =&#x27;dnumber1=$event.target.value&#x27;&gt; --&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; :value=&#x27;dnumber1&#x27; @input =&#x27;num1Input&#x27;&gt;</span><br><span class="line">            &lt;h2&gt;props:&#123;&#123;dnumber2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;h2&gt;data:&#123;&#123;num2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; :value=&#x27;dnumber2&#x27; @input =&#x27;num2Input&#x27;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>发射事件后，需要在父组件中监听，并在父组件中声明做出反应，将dnumber的值付给number,同时number的值就是num的值，故最后实现number和num的值相同并实现实时绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;cpn </span><br><span class="line">        :num1=&#x27;number1&#x27;</span><br><span class="line">        :num2=&#x27;number2&#x27;</span><br><span class="line"></span><br><span class="line">//监听事件</span><br><span class="line">        @num1change =&#x27;num1change&#x27;</span><br><span class="line">        @num2change =&#x27;num2change&#x27;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/cpn&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                number1:1,</span><br><span class="line">                number2:0</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                num1change(value)&#123;</span><br><span class="line"></span><br><span class="line">//传入的value的类型默认为字符串，通过parsInt()可以将value的类型转化为int类型</span><br><span class="line">                    this.number1 = parseInt(value),</span><br><span class="line">                    //this.number2 = parseInt(value)/10</span><br><span class="line">                &#125;,</span><br><span class="line">                num2change(value)&#123;</span><br><span class="line">                    this.number2 = parseInt(value),</span><br><span class="line">                    //this.number1 = parseInt(value)*10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然了，我们还可以使用watch来简化整个过程，我们回到将v-model拆开的部门。如果我们还是想要使用v-model的话，可以使用watch属性来对dnumber进行监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">            // 避免直接修改props中的值，直接修改可能会导致数据紊乱出错</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    dnumber1:this.num1,</span><br><span class="line">                    dnumber2:this.num2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            props:&#123;</span><br><span class="line">                num1:Number,</span><br><span class="line">                num2:Number</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line">                // 检测到dnumber发生变化后就触发事件</span><br><span class="line">                dnumber1(newValue)&#123;</span><br><span class="line">                    this.$emit(&#x27;num1change&#x27;,this.dnumber1);</span><br><span class="line">                &#125;,</span><br><span class="line">                dnumber2(newValue)&#123;</span><br><span class="line">                    this.$emit(&#x27;num1change&#x27;,this.dnumber2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其余操作相同。<br>链接：<a href="https://juejin.cn/post/7082436147279822879">https://juejin.cn/post/7082436147279822879</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>父子组件传值</title>
    <url>/2022/04/04/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>子件和父组件之间难免会涉及到数据传输的问题，尤其是在父（根）组件通过ajax请求获取数据后，在传入子组件中得以显示时。传输方式便显得尤为重要。</p>
<span id="more"></span>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6f28be593d14051a679c01760bf859a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>Vue提供的传输方法</p>
<h2 id="（父传子）props传输数据"><a href="#（父传子）props传输数据" class="headerlink" title="（父传子）props传输数据"></a>（父传子）props传输数据</h2><p>这里，我们不妨将实例app当做父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成一个实例</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:&#x27;我爱你&#x27;,</span><br><span class="line">                array:[1,2,3,4]</span><br><span class="line">            &#125;,</span><br><span class="line">            components:&#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">//注册组件cpn</span><br><span class="line">//需要注意的是我们在使用props传入数据时，需要在子组件外围设置一个根（一个包裹如div）</span><br><span class="line"> &lt;template id=&quot;cnp&quot; &gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;carray&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;cmessage&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line"> const cpn=&#123;</span><br><span class="line">            template:&#x27;#cnp&#x27;,</span><br><span class="line">//注册的组件的data必须是一个函数（用于返回对象）</span><br><span class="line">            data()&#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">//声明props</span><br><span class="line">传入父组件数据</span><br><span class="line">            props:&#123;</span><br><span class="line">                carray:Array,</span><br><span class="line">                cmessage:&#123;</span><br><span class="line">                    type:String,</span><br><span class="line">                    default:&quot;我日你先人&quot;,</span><br><span class="line">                    // 是否必须传值</span><br><span class="line">                    // required:true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">//使用v-bind语法糖</span><br><span class="line"></span><br><span class="line">//将array中的值绑定到carray中</span><br><span class="line">//将message中的值绑定到cmessage中</span><br><span class="line">        &lt;cpn :cArray=&quot;array&quot; :cMessage=&quot;message&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>至此，最简单的传值操作就已经完成了</p>
<p>值得注意的是，v-bind语句不支持驼峰命名法，若在props中的元素使用驼峰命名法，则需要在绑定值时使用 -分割线</p>
<h2 id="（子传父）自定义事件传递数据"><a href="#（子传父）自定义事件传递数据" class="headerlink" title="（子传父）自定义事件传递数据"></a>（子传父）自定义事件传递数据</h2><p>父传子时是通过props属性来完成的，而当我们遇到子传父时，则需要注册自定义事件</p>
<p>一般情况下，子组件发生了某个事件，我们希望父组件根据该事件做出相应的一个调整与反映。</p>
<p>同样的我，我们先创建一个子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button </span><br><span class="line">            v-for=&quot;item in categories&quot;</span><br><span class="line">            @click = &#x27;itemClick(item)&#x27;</span><br><span class="line">            &gt;&#123;&#123;item.name&#125;&#125;&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">        const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">                &#125;</span><br><span class="line">        const app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line"></span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>子传父的应用场景比较多的是子组件中发生了某些事件，我们希望父组件知道并且作出反映。在此，我们模拟一个简单的传输过程。现将整个子组件丰富一下，然后在此我们将自定义事件在子组件中进行一个注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> const cpn = &#123;</span><br><span class="line">            template: &#x27;#cnp&#x27;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    categories:[</span><br><span class="line">                        &#123;id:&#x27;111&#x27;,name:&#x27;apple&#x27;&#125;,</span><br><span class="line">                        &#123;id:&#x27;112&#x27;,name:&#x27;iphone&#x27;&#125;,</span><br><span class="line">                        &#123;id:&#x27;113&#x27;,name:&#x27;ipad&#x27;&#125;,</span><br><span class="line">                        &#123;id:&#x27;114&#x27;,name:&#x27;huawei&#x27;&#125;,</span><br><span class="line">                        &#123;id:&#x27;115&#x27;,name:&#x27;xiaomi&#x27;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                itemClick(item)&#123;</span><br><span class="line">                    // console.log(item);</span><br><span class="line">                    // 发射(事件,参数)</span><br><span class="line">                    this.$emit(&#x27;item-click&#x27;,item) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &lt;template id=&quot;cnp&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button </span><br><span class="line">            v-for=&quot;item in categories&quot;</span><br><span class="line">            @click = &#x27;itemClick(item)&#x27;</span><br><span class="line"></span><br><span class="line">//注册点击事件</span><br><span class="line">            &gt;&#123;&#123;item.name&#125;&#125;&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>子组件发射事件后，父组件需要对该事件进行监听，监听方式：在父组件的模板上使用v-on绑定事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">//以前我们使用v-on绑定的事件都是默认注册好的事件，自定义事件注册后，便可以在其作用域（父组件）内进行监听、绑定</span><br><span class="line">//监听的自定义事件的命名需要从驼峰命名法进行转化（使用脚手架可忽略）</span><br><span class="line">//若在监听事件时没有传入参数（如cpnClick(item)传入参数），将会默认传入子组件发射的参数，在这里为item</span><br><span class="line">        &lt;cpn @item-click=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;</span><br><span class="line">        &lt;div&gt;我爱&#123;&#123; things &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在父组件中注册监听后，还需要在父组件内部注册事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &#x27;我爱你&#x27;,</span><br><span class="line">                array: [1, 2, 3, 4],</span><br><span class="line">                things:&quot;NONE&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                cpnClick(item)&#123;</span><br><span class="line">                    console.log(item.id);</span><br><span class="line">                    this.things = item.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                cpn</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>至此，我们完成了对父传子操作的全过程。运行截图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e832e4a99eab43c2a96cbdd4463aa1c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b4140fe8c0488d8cee57b2161d38ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682923a1b22f408b8fc7725b72ea3f12~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<p>作者：用户4721573403919<br>链接：<a href="https://juejin.cn/post/7082435003316961311">https://juejin.cn/post/7082435003316961311</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vue创建组件</title>
    <url>/2022/04/04/vue%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>Vue组件创建两大步：1.创建组件 2.注册组件</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.创建组件构造器</span><br><span class="line">        const cpnC = Vue.extend(&#123;</span><br><span class="line">            template:`</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">                &lt;p&gt;我是&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            `</span><br><span class="line">        &#125;)</span><br><span class="line"> // 2.注册组件</span><br><span class="line">         Vue.component(&quot;firstcnp&quot;,cpnCC);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>注册组件简洁写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注册全局组件语法糖写法</span><br><span class="line">         Vue.component(&quot;firstcnp&quot;,&#123;</span><br><span class="line">             template:`</span><br><span class="line">             &lt;div&gt;</span><br><span class="line">                 &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">                 &lt;p&gt;我是&lt;/p&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">             `</span><br><span class="line">         &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然除了在script中写组件的内容以外，还可以在body中写组件的内容（更好写）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;template id=&quot;name2&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;我不是&lt;/h2&gt;</span><br><span class="line">            &lt;p&gt;但xx是&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"> Vue.component(&quot;cnp2&quot;,&#123;</span><br><span class="line">            template:&quot;#name2&quot;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>


<p>链接：<a href="https://juejin.cn/post/7082431612939403301">https://juejin.cn/post/7082431612939403301</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>v-model的常用事件修饰符</title>
    <url>/2022/04/04/v-model%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="lazy修饰符"><a href="#lazy修饰符" class="headerlink" title="lazy修饰符"></a>lazy修饰符</h4><p>默认情况下，v-model是与输入框中的value同步的，一旦有数据发生改变，data中与其双向绑定的数据也随之改变。使用lazy修饰符可以让数据在失去焦点或者回车时再进行更新。</p>
<span id="more"></span>**使用方法：v-model.lazy=”（绑定的数据）”**

<h4 id="number修饰符"><a href="#number修饰符" class="headerlink" title="number修饰符"></a>number修饰符</h4><p>默认情况下，在输入框中无论是输入字符还是数字，v-model绑定数据时均会按照字符串进行处理。当我们希望处理的时数字类型时（可以在input 的type属性中设置为number），使用number修饰符可以将其自动转化为数字类型，便于处理。<strong>使用方法：v-model.number&#x3D;”(绑定的数据)”</strong></p>
<h4 id="trim修饰符"><a href="#trim修饰符" class="headerlink" title="trim修饰符"></a>trim修饰符</h4><p>当输入的数据中左右两端存在很多的空格时，可以通过trim修饰符将左右两端的空格进行删除。<strong>使用方法：v-model.trim&#x3D;”(绑定的数据)”</strong></p>
<p>链接：<a href="https://juejin.cn/post/7082428951708041247">https://juejin.cn/post/7082428951708041247</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue初步</title>
    <url>/2022/04/04/Vue%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="什么是工程化"><a href="#什么是工程化" class="headerlink" title="什么是工程化"></a>什么是工程化</h2><p>你以为的前端开发：老三样，需要美化页面：bootstrap!,需要实现网页布局：Layui（然后最后写出个DEMO）</p>
<p>实际的前端开发：模块化+组件化+规范化+自动化（介都是嘛玩意儿啊）</p>
<span id="more"></span>

<p>那到底什么是前端工程化呢？前端工程化指的是，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。（说了半天还是不清楚）</p>
<h2 id="什么是VUE"><a href="#什么是VUE" class="headerlink" title="什么是VUE"></a>什么是VUE</h2><p>Vue是一款前端渐进式框架，可以提高前端开发效率。Vue通过MVVM模式,能够实现视图与模型的双向绑定。简单来说，就是数据变化的时候, 页面会自动刷新, 页面变化的时候，数据也会自动变化.</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f579a76fad6d43e88fcaee49fc5d8e97~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<h3 id="webpack的登场"><a href="#webpack的登场" class="headerlink" title="webpack的登场"></a>webpack的登场</h3><p>webpack是前端项目工程化的具体解决方案，它主要提供了友好的前端模块化开发支持以及代码压缩混淆处理（将多行代码压缩到一行，清除全部注释，压缩用以节约空间）、处理浏览器端的JavaScript的兼容性、性能优化等强大的功能。提高开发效率和可维护性（总而言之，就是webpack，行！）</p>
<p>目前，比较主流的前端开发框架如react、Vue都是基于webpack进行工程化开发的</p>
<h3 id="webpack的安装与配置"><a href="#webpack的安装与配置" class="headerlink" title="webpack的安装与配置"></a>webpack的安装与配置</h3><p>在终端运行如下命令，安装webpack相关的两个包：</p>
<p>npm install webpack webpack-cli -D</p>
<p>安装完webpack，vue的基本环节就算安装结束了。</p>
<h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><p>在初学Vue，写demo的时候，我们常常会看见以下代码 <code>const app = new Vue(&#123;          el:#app,          data:&#123;&#125;          &#125;)</code> 这就是一个最简单的Vue实例，其中<strong>el:挂载点</strong>，他是用来设置Vue实例挂载的元素（在这里挂载的就是id为app的一个div），Vue会管理el挂载的元素以及其内部的元素。可以使用其他的选择器，但是建议使用<strong>ID选择器</strong>。<strong>data:数据库</strong>，Vue中用到的数据都定义在data中，在渲染复杂类型的数据时，遵循js的语法。</p>
<h2 id="Vue指令与事件"><a href="#Vue指令与事件" class="headerlink" title="Vue指令与事件"></a>Vue指令与事件</h2><p>vue中提供了以下指令：</p>
<h3 id="V-on"><a href="#V-on" class="headerlink" title="V-on"></a>V-on</h3><p>V-on 用于给元素绑定事件，不多bb，直接看demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;你再点一下试试&quot; @click = &quot;doIt&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;别点了别点了！&quot; v-on:click = &quot;doIt&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;再点要破防惹！&quot; @dblclick = &quot;doIt&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot; v-html = &quot;message&quot; @click = &quot;nt&quot; style=&quot;text-decoration:none;&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app =new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message:&quot;我是真的无语&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            doIt:function()&#123;</span><br><span class="line">                alert(&quot;哭了&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            nt:function()&#123;</span><br><span class="line">                this.message +=&quot; 别戳了QAQ&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;`</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>值得一提的是，指令可以简写为@，平时在写代码的时候，鼓励大家使用这个语法糖。绑定的方法定义在<strong>methods</strong>属性中，方法内部可以通过<strong>this</strong>关键字访问在data中的数据。 除此之外，还可以将绑定的方法写成函数调用的形式，并传入自定义参数。 另外还有事件修饰符，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt; </span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;点我&quot; @click =&quot;doIt(6666,&#x27;ohNo&#x27;)&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app =new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            doIt:function(p1,p2)&#123;</span><br><span class="line">                console.log(p1);</span><br><span class="line">                console.log(p2);</span><br><span class="line">            &#125;,</span><br><span class="line">            sayHi:function()&#123;</span><br><span class="line">                alert(&quot;您真是个大可爱&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>更多的事件修饰符见vue官方文<a href="https://link.juejin.cn/?target=https://cn.vuejs.org/v2/api%23v-on">cn.vuejs.org&#x2F;v2&#x2F;api#v-on</a> 。</p>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>v-for，类似于python中的for，可以实时生成。它一般用作：根据数据生成列表结构（常常和数组结合使用），语法是<code>（item,index）in data </code>item是data中的属性，如果data是数组的话,item就是数组中的每个数值，index是item的索引,v-for的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&quot;item in Arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;li v-for = &quot;boy in boys&quot;&gt;&#123;&#123;boy.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;add&quot; @click = &quot;add&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;remove&quot; @click = &quot;remove&quot; &gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for = &quot;boy in boys&quot;&gt;&#123;&#123;boy.name&#125;&#125;&lt;/li&gt;    </span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var app =new Vue(&#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                Arr:[&#x27;北京&#x27;,&#x27;天津&#x27;,&#x27;成都&#x27;,&#x27;上海&#x27;],</span><br><span class="line">                boys:[</span><br><span class="line">                    &#123;name:&quot;bovi&quot;,age:18&#125;,</span><br><span class="line">                    &#123;name:&quot;jeff&quot;,age:19&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                add:function()&#123;</span><br><span class="line">                    this.boys.push(&#123;name:&quot;kevin&quot;,age:12&#125;);</span><br><span class="line">                &#125;,</span><br><span class="line">                remove:function()&#123;</span><br><span class="line">                    this.boys.shift();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>数组长度的更新会同步到页面上，是<strong>响应式</strong>的，在上例中，如果点击第一个button，将会在页面中添加一个li，内容为kevin，同理，如果点击第二个button，页面中将会减少一个li。item和index可以结合其他指令一起使用。例如，在上例中我们获得的每个boy都是一个对象，可以通过boy.age获取拿到的boy中的age属性的值。</p>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>v-if：根据值的真假切换元素的显示与隐藏（直接在dom树中移除、添加）指令后的内容，最终都将解析为boolean，值为true的元素显示，值为false的元素隐藏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;p v-if = &quot;true&quot;&gt;我就是个P&lt;/p&gt;</span><br><span class="line">        &lt;span v-if = &quot;isShow&quot;&gt;我是咋办&lt;/span&gt;</span><br><span class="line">        &lt;p v-if = &quot;isShow&quot;&gt;我就是个P&lt;/p&gt;</span><br><span class="line">        &lt;span v-if = &quot;isShow&quot;&gt;我是span&lt;/span&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;改变可见度&quot; @dblclick =&quot;changeIsShow&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var app = new Vue(&#123;</span><br><span class="line">            el:&quot;#app&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                isShow:false</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                changeIsShow:function()&#123;</span><br><span class="line">                    this.isShow = !this.isShow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>和v-if相对应的就是v-show</p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show:根据值的真假，切换元素的显示与隐藏（仅仅改变对象的display）指令后的内容，最终都将解析为boolean，值为true的元素显示，值为false的元素隐藏，数据发生改变后，对应元素的显示状态将会同步更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button value=&quot;点击切换&quot; @click = &quot;changeIsShow&quot;&gt;&lt;/button&gt;</span><br><span class="line">    &lt;img src=&quot;素材/005.jpeg&quot; alt=&quot;&quot; v-show=&quot;true&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;素材/005.jpeg&quot; alt=&quot;&quot; v-show=&quot;isShow&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;素材/005.jpeg&quot; alt=&quot;&quot; v-show=&quot;age&gt;18&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app =new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            isShow:false,</span><br><span class="line">            age:17</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeIsShow:function()&#123;</span><br><span class="line">                this.isShow=!this.isShow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果经常切换，建议使用v-show（避免多次修改dom树），反之使用v-if（速度更快）。</p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>v-model:与数据绑定，实时进行修改（双方同时）。即： 绑定的数据&lt;–&gt;表单元素值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;message&quot; @keyup.enter=&quot;getMessage&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var app = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;我是谁？&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                getMessage:function()&#123;</span><br><span class="line">                    alert(this.message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>v-model指令的作用是便于设置、获取表单元素的值</p>
<p><a href="https://juejin.cn/post/7082426039946706975">https://juejin.cn/post/7082426039946706975</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇的display</title>
    <url>/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/</url>
    <content><![CDATA[<p>display可是个神奇的东西，通过修改display可以帮助组件实现“逆天改命”，变成其他组件的“模样”，当然，修炼之路不乏贫困，让我们一起来看看都有些什么神奇的display可供更改。</p>
<span id="more"></span>

<h1 id="display-none"><a href="#display-none" class="headerlink" title="display:none"></a>display:none</h1><p>display:none，如同其名字，也就是将整个组件给弄没了，注意，这里的display：none与将该组件从dom树上彻底删除有着很大区别，display:none仅仅是将该组件隐藏，通常用于制作二级菜单：想将其display设置为none，然后当鼠标滑过一级菜单时再将其display改为block。</p>
<p>display:none可以让比较复杂的界面简洁化，使这个网页（界面）视觉重量减轻。除此之外，在排他算法中display:none也经常用到。</p>
<hr>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C1.png" alt="img"></p>
<blockquote>
<p>“we can only see short distance ahead,but we can see plenty there that needs to be none”</p>
<p>— Alan Turing, <em>Computer scientist</em></p>
</blockquote>
<hr>
<h1 id="display-block、inline"><a href="#display-block、inline" class="headerlink" title="display:block、inline"></a>display:block、inline</h1><p>根据css的规定，一些组件有着其默认的display值，常用的div的默认display值为block，为“块级元素”(block-level ),而作为块级元素，其高度、宽度、内距以及外距都可以进行调整。</p>
<p>块级元素特点：</p>
<ol>
<li>每个块级元素都从新的一行开始（一块霸占一行）</li>
<li>在其本身的宽度不进行设置时，其宽度默认为其父级组件的宽度（body也算父级组件）。</li>
<li>可以设置padding和margin</li>
</ol>
<p>常用的 块级元素有：</p>
<p>div、p、h1…h6、ol、ul、dl、table、address、blockquote （块引用）、form</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&#x27;display:inline’&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>而如链接元素a，其默认display值为inline，为“行内元素”，它是依附于其他块级元素存在的，故行内元素是无法设置高度、宽度等属性，在设置margin时只有left、right的时候，与此同时可以设置padding（若想设置，应该将其display强制转化为block）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span style=&#x27;display:block’&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>常用的行内元素有：</p>
<p>a、span、br、i、em、strong、label、q、var、cite、code（表示计算机源代码或者其他机器可以阅读的文本内容）什么是Flex布局</p>
<h1 id="什么是inline-block"><a href="#什么是inline-block" class="headerlink" title="什么是inline-block"></a>什么是inline-block</h1><p>上文提到了display:block和display:inline，其中inline可以排列在一行但无法设置整个组件的高度与宽度,block可以设置组件大小但又只能单独一个组件占一行，为了解决这一尴尬的问题，inline-block孕育而生。</p>
<p>inline-block（融合行内于块级）结合了inline和block的特点，能够与其他行内元素共享一行的同时可以改变元素的高度以及宽度，同时还可以设置padding和margin。</p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C2.png" alt="img"></p>
<p>设置为inline-block后，几个元素可以在同一行显示，这个效果跟浮动基本上一样，但也有不同。</p>
<h2 id="inline-block-Vs-float"><a href="#inline-block-Vs-float" class="headerlink" title="inline-block Vs float"></a>inline-block Vs float</h2><p>相同之处：效果能够基本上达到一样的效果</p>
<p>不同之处：设置浮动后容易导致父元素高度坍塌，而且float会导致元素脱离文本流；display:inline-block不会使元素脱离文本流。</p>
<p>我们来对对比一下display：inline-block和float的效果</p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C3.png" alt="img"></p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C4.png" alt="img"></p>
<p>设置overfloat:hidden防止父元素高度坍塌</p>
<p>如果每一个子元素高度相同，那么display:inline-block和float没有什么区别，但是每个子元素高度不同的时候float和inline-block的差距就比较明显了。</p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C9.png" alt="img"></p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C8.png" alt="img"></p>
<p>若要元素排满一行，换行后还要整齐排列，就要子元素的高度一致才行，不然就会出现图三的效果，而inline-block就不会。</p>
<h2 id="inline-block存在的问题"><a href="#inline-block存在的问题" class="headerlink" title="inline-block存在的问题"></a>inline-block存在的问题</h2><p>大家可以看使用了display:inline-block后，每个组件之间会存在间隙问题（4px)，这个问题其实不是inline-block的问题，而是我们写标签时随手打的回车符（原来是你）。</p>
<p>去除空隙的方法也很简单，对父元素添加font-size：0，将空白符的大小变成0px，从而消除空隙。</p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C5.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果要使用横向排列，那就大胆的使用inline-block；如果使用文字环绕就要使用浮动了。</p>
<h1 id="什么是flex"><a href="#什么是flex" class="headerlink" title="什么是flex"></a>什么是flex</h1><p>我们首先来解读一下flex是什么意思。flex就是flexible box的缩写，译为弹性布局，如同其名，弹性布局就是为了给盒型模型提供最大的灵活性。其中，每一个容器都可以指定为flex（行内元素也可：inline-flex)。Webkit为内核的浏览器，则必须加上-webkit前缀（如display: -webkit -flex)</p>
<p>使用Flex布局的元素称为称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。在设置属性display&#x3D;flex时，需要将其赋值于容器上，项目则不需要。</p>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C6.png" alt="img">默认存在两条主轴：水平的主轴（main axis）和垂直的交叉轴（cross axis)</p>
<h3 id="Flex-VS-Float"><a href="#Flex-VS-Float" class="headerlink" title="Flex VS Float"></a>Flex VS Float</h3><p>我们经常需要完成将多个照片并排放置的工作，此时比较简单的做法就是设置float，但是float会出现父组件高度坍塌等问题，此时，我们就需要使用flex布局进行图片的放置。</p>
<h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><ul>
<li>flex-direction</li>
<li>justify-content</li>
<li>align-items</li>
<li>flex-wrap</li>
<li>align-content</li>
<li>flex-flow</li>
</ul>
<h4 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1.flex-direction"></a>1.flex-direction</h4><p>项目（flex item)默认情况下是沿着主轴从main start 开始往main end 方向进行排序。而属性flex-direction决定了主轴的方向。其中flex-direction有四个取值（row(默认值)、row-reverse、column(自上而下）、column-reverse)</p>
<h4 id="2-justify-content"><a href="#2-justify-content" class="headerlink" title="2.justify-content"></a>2.justify-content</h4><p>这个属性主要用来排列主轴上各个项目(item)的位置，决定了项目在主轴上的对齐方式</p>
<p>属性值：</p>
<ul>
<li>flex-start(默认值):与main start对齐</li>
<li>flex-end：与main end对齐</li>
<li>center：居中</li>
<li>space-between：flex items 之间的距离相等，与main start、main end两端对齐</li>
<li>space-evenly: flex items 之间的距离相等,flex items与main start 、main end 之间的距离等于flex items之间的距离</li>
<li>space-around :flex items 之间的距离相等,flex items与main start 、main end 之间的距离等于flex items之间的距离的一半</li>
</ul>
<p>值得注意的是这些都<strong>是容器的属性</strong></p>
<h4 id="3-align-items"><a href="#3-align-items" class="headerlink" title="3.align-items"></a>3.align-items</h4><p>这个属性是用于决定项目（items)在纵轴上的对齐方式</p>
<p>属性值：</p>
<ul>
<li>normal：在弹性布局中，效果和stretch一样</li>
<li>stretch：前提是items不设置高度，当flex items 在cross axis 方向的size为auto时，会自动拉伸至填充flex container(或者换句话说：如果项目未设置高度或设为auto，将占满整个容器的高度。)</li>
<li>flex-satrt:与cross start 对齐</li>
<li>flex-end:与cross end 对齐</li>
<li>center:居中对齐</li>
<li>baseline:与基准线对齐</li>
</ul>
<h4 id="4-flex-wrap"><a href="#4-flex-wrap" class="headerlink" title="4.flex-wrap"></a>4.flex-wrap</h4><p>决定了flex container 是单行还是多行,默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>
<p>属性值：</p>
<ul>
<li>nowrap(默认)：单行</li>
<li>warp：多行 &#x2F;&#x2F;这个比较少用</li>
<li>wrap-reverse:多行（对比wrap，cross start 与cross end相反）</li>
</ul>
<h4 id="5-align-content"><a href="#5-align-content" class="headerlink" title="5.align-content"></a>5.align-content</h4><p>决定了多行flex items 在cross axis的对齐方式 用法与justify-content相似 一个是横轴。一个控制竖轴</p>
<p>属性值：</p>
<ul>
<li>stretch(默认值)：与align-items的stretch类似，当items有高度的时候，无效果</li>
<li>flex-start:与cross start 对齐</li>
<li>flex-end :与cross end 对齐</li>
<li>center：居中对齐</li>
<li>space-between:flex items 之间的距离相等，与cross start、cross end两端对齐</li>
<li>space-evently: flex items 之间的距离相等,flex items与cross start 、cross end 之间的距离等于flex items之间的距离</li>
<li>space-around :flex items 之间的距离相等,flex items与cross start 、cross end 之间的距离等于flex items之间的距离的一半</li>
</ul>
<p><img src="/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/%E7%A5%9E%E5%A5%87%E7%9A%84display%5C7.jpg" alt="img"></p>
<h3 id="flex项目属性（item属性）"><a href="#flex项目属性（item属性）" class="headerlink" title="flex项目属性（item属性）"></a>flex项目属性（item属性）</h3><h4 id="1-order"><a href="#1-order" class="headerlink" title="1.order"></a>1.order</h4><p>order决定了该项目在容器中的顺序，可以设置为任意整数，默认为0，值越小，排的越靠前。</p>
<h4 id="2-align-self"><a href="#2-align-self" class="headerlink" title="2. align-self"></a>2. align-self</h4><p>设置该属性可以覆盖容器的设置的align-items，属性值及其对应的效果与align-items一致。</p>
<h4 id="3-flex-grow"><a href="#3-flex-grow" class="headerlink" title="3.flex-grow"></a>3.flex-grow</h4><p>决定了flex items如何扩展<br>可以设置为任意非父数字（小数，整数 0），默认为0<br>当flex container 在main axis方向上有剩余得size时，flex-grow属性才会有效</p>
<p>如果所有flex items 的flex-grow 综合sum不超过1，这直接乘以剩余size就是扩展大小、<br>如果超过1 扩展size&#x3D;剩余size*flex-grow&#x2F;sum</p>
<p><strong>当设置flex:1时，每个子组件将会均匀的分布（水平）在flex容器中</strong></p>
<h4 id="4-flex-shrink"><a href="#4-flex-shrink" class="headerlink" title="4.flex-shrink"></a>4.flex-shrink</h4><p>flex-shrink (shrink 缩小，收缩)与flex-grow相似，一个扩展，一个伸缩<br>可以设置为任意非父数字（小数，整数 0），默认为1<br>当flex items在main axis 方向上超过了flex container 的size flex-shrink属性才会生效、<br>如果所有flex items 的flex-shrink 总和sum超过1，每个flex item 收缩的size为：<br>flex item 超出flex container 的size*收缩比例&#x2F;每个flex items 的收缩比例之和<br>如果sum不超过1，每个flex item 收缩的size为：<br>size &#x3D; 超出的size * flex-shrink值<br>flex items收缩后的最终size不能小于min-width\min-height</p>
<h4 id="5-flex-basis"><a href="#5-flex-basis" class="headerlink" title="5.flex-basis"></a>5.flex-basis</h4><p>用来设置flex items 在 main axis方向上的base size<br>默认为auto，可以设置具体的宽度数值 决定flex items最终base size 的因素，优先级从高到低</p>
<ul>
<li>max-width\max-height\min-width\min-height</li>
<li>flex-basis width\height</li>
<li>内容本身的size</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>图片自适应大小</title>
    <url>/2022/04/01/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>在一般设计中，插入图片有两种方式，一是在组件中添加background属性，一是通过<img>组件。两种方式实现自适应的方式大同小异。</p>
<span id="more"></span>

<h3 id="背景图适应大小"><a href="#背景图适应大小" class="headerlink" title="背景图适应大小"></a>背景图适应大小</h3><p>当外层容器的宽高比跟图片宽高比一致时到没啥问题，但在一些特定的业务场景，如九宫格图片展示时，展示的原始图片它们的大小，宽高比很有可能是不一样的，但外层容器的大小是固定的。此时如果按照上面的做法会导致图片被拉伸或者压缩。为了让图片显示的自然，我们可以让图片中的一部分去填充整个容器，虽然这样做无法让图片显示完整，但也避免了因图片的拉伸或压缩导致的变形。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div&#123;</span><br><span class="line">width: 200px；</span><br><span class="line">height: 200px;</span><br><span class="line">background: url(&#x27;xxxx.png&#x27;) no-repeat;</span><br><span class="line">background-size: cover;</span><br><span class="line">background-position: center center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="图片自适应容器宽高"><a href="#图片自适应容器宽高" class="headerlink" title="图片自适应容器宽高"></a>图片自适应容器宽高</h3><p>css实现图片自适应容器宽高的做法一般如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">div&#123;width: 200px; height: 200px&#125;</span><br><span class="line">div img&#123;width: 100%; height: 100%&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;img src=&quot;xxxx.png&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>居中</title>
    <url>/2022/04/01/%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>居中的方式有很多，其中，有不少是伪居中，具体表现为看样子是居中了，但是详细查看位置后发现其实没有居中，在这里提供两种居中思路：绝对位置居中以及弹性盒子居中</p>
<span id="more"></span>

<h3 id="绝对位置居中"><a href="#绝对位置居中" class="headerlink" title="绝对位置居中"></a>绝对位置居中</h3><p>绝对位置居中的核心思想就是通过绝对定位的方式实现居中，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">style&#123;</span><br><span class="line">    //给父体一个绝对定位</span><br><span class="line">    .div&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    //给子体相对定位</span><br><span class="line">    .object&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top:50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>top: 50%;left: 50%;， 是以左上角为原点，故不处于中心位置，<br>translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p>
<h3 id="弹性盒子居中"><a href="#弹性盒子居中" class="headerlink" title="弹性盒子居中"></a>弹性盒子居中</h3><p>弹性盒子居中主要使用justify-content、 align-items 属性，</p>
<p>justify-content:center;&#x2F;* 子元素水平居中 *&#x2F;</p>
<p>align-items:center;&#x2F;* 子元素垂直居中 *&#x2F;</p>
<p>其中justify-content是flex布局中父项的一个比较常见的属性，justify-content 属性定义了项目在主轴上的对齐方式。</p>
<p><img src="/2022/04/01/%E5%B1%85%E4%B8%AD/%E5%B1%85%E4%B8%AD%5C1.png" alt="img"></p>
<p><a href="https://www.w3.org/TR/css-flexbox-1/#propdef-align-items">align-items</a>属性可以应用于所有的flex容器，它的作用是设置flex子项在每个flex行的交叉轴上的默认对齐方式。不同取值的效果如下所示：<br><a href="https://www.w3.org/TR/css-flexbox-1/#propdef-align-items">align-item</a></p>
<p><img src="/2022/04/01/%E5%B1%85%E4%B8%AD/%E5%B1%85%E4%B8%AD%5C2.png" alt="img"></p>
<p>align-items属性是针对单独的每一个flex子项起作用，它的基本单位是每一个子项，在所有情况下都有效果（当然要看具体的属性值）。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的原型和原型链</title>
    <url>/2022/04/01/JS%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>讲原型的时候，我们应该先要记住以下几个要点，这几个要点是理解原型的关键：</p>
<span id="more"></span>

<p>1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。</p>
<p>2、所有的引用类型都有一个’_ _ proto_ _’属性(也叫隐式原型，它是一个普通的对象)。</p>
<p>3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。</p>
<p>4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。</p>
<p>5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。</p>
<p>那么要点说完了，我们就根据这些要点来理解原型和原型链。</p>
<p>原型<br>我们先来看一个原型的例子。</p>
<pre><code>    //这是一个构造函数
    function Foo(name,age)&#123;
        this.name=name;
        this.age=age;
    &#125;
    /*根据要点3，所有的函数都有一个prototype属性，这个属性是一个对象
    再根据要点1，所有的对象可以自由扩展属性
    于是就有了以下写法*/
    Foo.prototype=&#123;
        // prototype对象里面又有其他的属性
        showName:function()&#123;
            console.log(&quot;I&#39;m &quot;+this.name);//this是什么要看执行的时候谁调用了这个函数
        &#125;,
        showAge:function()&#123;
            console.log(&quot;And I&#39;m &quot;+this.age);//this是什么要看执行的时候谁调用了这个函数
        &#125;
    &#125;
    var fn=new Foo(&#39;小明&#39;,19)
    /*当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它
    构造函数的&#39;prototype&#39;属性中去找*/
    fn.showName(); //I&#39;m 小明
    fn.showAge(); //And I&#39;m 19
这就是原型，很好理解。那为什么要使用原型呢？
</code></pre>
<p>试想如果我们要通过Foo()来创建很多很多个对象，如果我们是这样子写的话：</p>
<pre><code>function Foo(name,age)&#123;
        this.name=name;
        this.age=age;
        this.showName=function()&#123;
            console.log(&quot;I&#39;m &quot;+this.name);
        &#125;
        this.showAge=function()&#123;
            console.log(&quot;And I&#39;m &quot;+this.age);
        &#125;
    &#125;
那么我们创建出来的每一个对象，里面都有showName和showAge方法，这样就会占用很多的资源。
而通过原型来实现的话，只需要在构造函数里面给属性赋值，而把方法写在Foo.prototype属性(这个属性是唯一的)里面。这样每个对象都可以使用prototype属性里面的showName、showAge方法，并且节省了不少的资源。
</code></pre>
<p>原型链<br>理解了原型，那么原型链就更好理解了。</p>
<p>下面这段话可以帮助理解原型链<br>根据要点5，当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它构造函数的’prototype’属性中去寻找。那又因为’prototype’属性是一个对象，所以它也有一个’_ _ proto_ _’属性。</p>
<p>那么我们来看一个例子：</p>
<pre><code>    // 构造函数
    function Foo(name,age)&#123;
         this.name=name;
         this.age=age;
    &#125;
    Object.prototype.toString=function()&#123;
        //this是什么要看执行的时候谁调用了这个函数。
        console.log(&quot;I&#39;m &quot;+this.name+&quot; And I&#39;m &quot;+this.age);
    &#125;
    var fn=new Foo(&#39;小明&#39;,19);
    fn.toString(); //I&#39;m 小明 And I&#39;m 19
    console.log(fn.toString===Foo.prototype.__proto__.toString); //true
    
    console.log(fn.__proto__ ===Foo.prototype)//true
    console.log(Foo.prototype.__proto__===Object.prototype)//true
    console.log(Object.prototype.__proto__===null)//true
是不是觉得有点奇怪？我们来分析一下。
</code></pre>
<p>首先，fn的构造函数是Foo()。所以：<br>fn._ _ proto _ <em>&#x3D;&#x3D;&#x3D; Foo.prototype<br>又因为Foo.prototype是一个普通的对象，它的构造函数是Object，所以：<br>Foo.prototype.</em> _ proto _ _&#x3D;&#x3D;&#x3D; Object.prototype<br>通过上面的代码，我们知道这个toString()方法是在Object.prototype里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到null为止。</p>
<p>所以当fn调用toString()时，JS发现fn中没有这个方法，于是它就去Foo.prototype中去找，发现还是没有这个方法，然后就去Object.prototype中去找，找到了，就调用Object.prototype中的toString()方法。</p>
<p>这就是原型链，fn能够调用Object.prototype中的方法正是因为存在原型链的机制。</p>
<p>另外，在使用原型的时候，一般推荐将需要扩展的方法写在构造函数的prototype属性中，避免写在_ _ proto _ _属性里面。</p>
<p><a href="https://blog.csdn.net/qq_36996271/article/details/82527256">https://blog.csdn.net/qq_36996271/article/details/82527256</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS高阶函数使用</title>
    <url>/2022/04/01/JS%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>首先是for循环的一种简化写法，主要针对数组遍历</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.常规for循环</span><br><span class="line">            let price=0;</span><br><span class="line">            for(let i = 0;i&lt;this.books.length;i++)&#123;</span><br><span class="line">                price+=this.books[i].price*this.books[i].count;</span><br><span class="line">            &#125;</span><br><span class="line">            return price;</span><br><span class="line">            2.for(let i in this.books)</span><br><span class="line">            let price=0;</span><br><span class="line">            for(let i in this.books)&#123;</span><br><span class="line">                price+=this.books[i].price*this.books[i].count;</span><br><span class="line">            &#125;return price;</span><br><span class="line">           3.for(let i of this.books)</span><br><span class="line">           let price=0;</span><br><span class="line">           for(let book of this.books)&#123;</span><br><span class="line">               price+=book.price*book.count;</span><br><span class="line">           &#125;return price;</span><br></pre></td></tr></table></figure>

<p><strong>filter函数</strong>（过滤函数）：中有一个回调函数，每读入数组中的一个元素便调用一次（返回一个Boolean值），当返回值为true时，函数内部将会自动将这次的回调的n加入新的数组，若为false，则过滤掉这次的n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nums=[1,2,4,5,10,32,44];</span><br><span class="line">let  newNums = nums.filter(function(n)&#123;</span><br><span class="line">      return n&lt;6;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newNums)</span><br><span class="line"></span><br><span class="line">简洁写法：</span><br><span class="line">let newNums = nums.filter(n =&gt; n&lt;6);</span><br><span class="line">//最后获得结果[1,2,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>map函数</strong>（遍历函数）：中有一个回调函数， 每读入数组中的一个元素便调用一次 ，并将返回值自动加入新的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nums=[1,2,4,5,10,32,44];</span><br><span class="line">let  newNums = nums.map(function(n)&#123;</span><br><span class="line">      return n*2;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newNums)</span><br><span class="line"></span><br><span class="line">简洁写法:</span><br><span class="line">let newNums=nums.map(n =&gt; n*2)</span><br><span class="line">//最后获得结果[2,4,8,10,20,64,88]</span><br></pre></td></tr></table></figure>

<p><strong>reduce函数</strong>（汇总函数）：中有两个传入参数—-reduce（参数一,参数二）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nums=[1,2,4,5];</span><br><span class="line">let  newNum = nums.reduce(function(preValue,n)&#123;</span><br><span class="line">      return preValue+n;</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(newNum)</span><br><span class="line">第一次：preValue 0 n 1</span><br><span class="line">第二次：preValue 1 n 2</span><br><span class="line">第三次：preValue 3 n 4</span><br><span class="line">第四次：preValue 7 n 5</span><br><span class="line">第五次：preValue 12</span><br><span class="line">最后输出12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">简洁写法:</span><br><span class="line">let newNum = nums.reduce((preValue,n) =&gt; preValue+n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数</title>
    <url>/2022/04/01/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>箭头函数，是ES6语法中定义函数的一个非常方便的语法。通常我们在将一个函数作为参数传入另一个函数时使用箭头函数，我们先来看一个最简单的例子。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const aaa = function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cost bbb = ()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//aaa与bbb等效</span><br></pre></td></tr></table></figure>

<p>通过简单的&#x3D;&gt;就可以生成一个函数，确实会比之前的方式简单许多，箭头函数的格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（参数列表）=&gt; &#123;</span><br><span class="line">//代码块</span><br><span class="line">&#125;</span><br><span class="line">//如果参数只有一个，则小括号可以省略</span><br><span class="line">//如果代码块中的代码只有一行，则可以省略大括号，并将该代码置于箭头后，计算机将会运行改行代码，并自动将其运行结果作为返回值</span><br></pre></td></tr></table></figure>

<p>值得注意的是在箭头函数中应用this，此时this指向的是 一层层往外层作用域寻找，直到找到最近的this定义</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的回调函数</title>
    <url>/2022/04/01/JS%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>什么是回调函数？回调的英文定义：A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。（回调是一种函数，它将作为参数传递给另一个函数，并且在其父函数完成后执行。  ps.谷歌机翻）字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。也就是说<strong>主函数的事先干完，回头再调用传进来的那个函数</strong>。</p>
<span id="more"></span>

<p>一个简单的案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义主函数，回调函数作为参数</span><br><span class="line">function A(callback) &#123;</span><br><span class="line">    callback();  </span><br><span class="line">    console.log(&#x27;我是主函数&#x27;);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义回调函数</span><br><span class="line">function B()&#123;</span><br><span class="line">    setTimeout(&quot;console.log(&#x27;我是回调函数&#x27;)&quot;, 5000);//模仿异步操作  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用主函数，将函数B传进去</span><br><span class="line">A(B);</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">我是主函数</span><br><span class="line">我是回调函数</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们先定义了主函数和回调函数，然后再去调用主函数，将回调函数传进去。定义主函数的时候，我们让代码先去执行callback()回调函数，但输出结果却是后输出回调函数的内容。也就是说<strong>主函数不用等待回调函数执行完，可以接着执行自己的代码</strong>。所以一般回调函数都用在异步操作上面。比如ajax请求，比如处理文件等。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类型判断</title>
    <url>/2022/04/01/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>类型判断在 web 开发中有非常广泛的应用，简单的有判断数字还是字符串，进阶一点的有判断数组还是对象，再进阶一点的有判断日期、正则、错误类型，再再进阶一点还有比如判断 plainObject、空对象、Window 对象等等。</p>
<span id="more"></span>

<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><hr>
<p>我们最最常用的莫过于 typeof，注意，尽管我们会看到诸如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof(&#x27;yayu&#x27;)) // string</span><br></pre></td></tr></table></figure>

<p>的写法，但是 typeof 可是一个正宗的运算符，就跟加减乘除一样！这就能解释为什么下面这种写法也是可行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof &#x27;yayu&#x27;) // string</span><br></pre></td></tr></table></figure>

<p>引用《JavaScript权威指南》中对 typeof 的介绍：</p>
<blockquote>
<p>typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。</p>
</blockquote>
<p>那我们都知道，在 ES6 前，JavaScript 共六种数据类型，分别是：</p>
<p>Undefined、Null、Boolean、Number、String、Object</p>
<p>然而当我们使用 typeof 对这些数据类型的值进行操作的时候，返回的结果却不是一一对应，分别是：</p>
<p>undefined、object、boolean、number、string、object</p>
<p>注意以上都是小写的字符串。Null 和 Object 类型都返回了 object 字符串。</p>
<p>尽管不能一一对应，但是 typeof 却能检测出函数类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a() &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(typeof a); // function</span><br></pre></td></tr></table></figure>

<p>所以 typeof 能检测出六种类型的值，但是，除此之外 Object 下还有很多细分的类型呐，如 Array、Function、Date、RegExp、Error 等。</p>
<p>如果用 typeof 去检测这些类型，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">var error = new Error();</span><br><span class="line">console.log(typeof date); // object</span><br><span class="line">console.log(typeof error); // object</span><br></pre></td></tr></table></figure>

<p>返回的都是 object 呐，这可怎么区分~ 所以有没有更好的方法呢？</p>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><hr>
<p>那 Object.protototype.toString 究竟是一个什么样的方法呢？</p>
<p>为了更加细致的讲解这个函数，让我先献上 ES5 规范地址：<a href="https://es5.github.io/#x15.2.4.2%E3%80%82">https://es5.github.io/#x15.2.4.2。</a></p>
<p>在第 15.2.4.2 节讲的就是 Object.prototype.toString()，为了不误导大家，我先奉上英文版：</p>
<blockquote>
<p>When the toString method is called, the following steps are taken:</p>
</blockquote>
<ol>
<li>If the <strong>this</strong> value is <strong>undefined</strong>, return “**[object Undefined]**“.</li>
<li>If the <strong>this</strong> value is <strong>null</strong>, return “**[object Null]**“.</li>
<li>Let <em>O</em> be the result of calling ToObject passing the <strong>this</strong> value as the argument.</li>
<li>Let <em>class</em> be the value of the [[Class]] internal property of <em>O</em>.</li>
<li>Return the String value that is the result of concatenating the three Strings “**[object** “, <em>class</em>, and “**]**“.</li>
</ol>
<p>凡是规范上加粗或者斜体的，在这里我也加粗或者斜体了，就是要让大家感受原汁原味的规范！</p>
<p>如果没有看懂，就不妨看看我理解的：</p>
<p>当 toString 方法被调用的时候，下面的步骤会被执行：</p>
<ol>
<li>如果 this 值是 undefined，就返回 [object Undefined]</li>
<li>如果 this 的值是 null，就返回 [object Null]</li>
<li>让 O 成为 ToObject(this) 的结果</li>
<li>让 class 成为 O 的内部属性 [[Class]] 的值</li>
<li>最后返回由 “[object ” 和 class 和 “]” 三个部分组成的字符串</li>
</ol>
<p>通过规范，我们至少知道了调用 Object.prototype.toString 会返回一个由 “[object ” 和 class 和 “]” 组成的字符串，而 class 是要判断的对象的内部属性。</p>
<p>让我们写个 demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(undefined)) // [object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(null)) // [object Null]</span><br><span class="line"></span><br><span class="line">var date = new Date();</span><br><span class="line">console.log(Object.prototype.toString.call(date)) // [object Date]</span><br></pre></td></tr></table></figure>

<p>由此我们可以看到这个 class 值就是识别对象类型的关键！</p>
<p>正是因为这种特性，我们可以用 Object.prototype.toString 方法识别出更多类型！</p>
<p>那到底能识别多少种类型呢？</p>
<p>至少 12 种！</p>
<p>你咋知道的？</p>
<p>我数的！</p>
<p>……</p>
<p>让我们看个 demo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以下是11种：</span><br><span class="line">var number = 1;          // [object Number]</span><br><span class="line">var string = &#x27;123&#x27;;      // [object String]</span><br><span class="line">var boolean = true;      // [object Boolean]</span><br><span class="line">var und = undefined;     // [object Undefined]</span><br><span class="line">var nul = null;          // [object Null]</span><br><span class="line">var obj = &#123;a: 1&#125;         // [object Object]</span><br><span class="line">var array = [1, 2, 3];   // [object Array]</span><br><span class="line">var date = new Date();   // [object Date]</span><br><span class="line">var error = new Error(); // [object Error]</span><br><span class="line">var reg = /a/g;          // [object RegExp]</span><br><span class="line">var func = function a()&#123;&#125;; // [object Function]</span><br><span class="line"></span><br><span class="line">function checkType() &#123;</span><br><span class="line">    for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        console.log(Object.prototype.toString.call(arguments[i]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)</span><br></pre></td></tr></table></figure>

<p>除了以上 11 种之外，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(Math)); // [object Math]</span><br><span class="line">console.log(Object.prototype.toString.call(JSON)); // [object JSON]</span><br></pre></td></tr></table></figure>

<p>除了以上 13 种之外，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。</p>
<h4 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h4><hr>
<p>Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，这点在<a href="https://github.com/mqyqingfeng/Blog/issues/5">《JavaScript深入之变量对象》</a>中讲到过。我们可以利用这个特性判断是否是 Window 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isWindow( obj ) &#123;</span><br><span class="line">    return obj != null &amp;&amp; obj === obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><hr>
<p>instanceof 可以用于判断测试者和目标是不是同一个类型，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Car(make, model, year) &#123;</span><br><span class="line">  this.make = make;</span><br><span class="line">  this.model = model;</span><br><span class="line">  this.year = year;</span><br><span class="line">&#125;</span><br><span class="line">const auto = new Car(&#x27;Honda&#x27;, &#x27;Accord&#x27;, 1998);</span><br><span class="line"></span><br><span class="line">console.log(auto instanceof Car);</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">console.log(auto instanceof Object);</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://github.com/mqyqingfeng/Blog/issues/28">JavaScript专题之类型判断(上) · Issue #28 · mqyqingfeng&#x2F;Blog · GitHub</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>This理解</title>
    <url>/2022/04/01/This%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>this，从字面意思上来讲，即这个。但这个，又是哪个呢？ 在使用this的时候常常会遇到一些问题，时常会出现this指向不明的问题（你以为的this并不是真正的this）。那让我们溯源一下，到底什么是this。</p>
<span id="more"></span>

<ul>
<li>this是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。</li>
<li><strong>this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时</strong>。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 <strong>这，这个</strong> ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 <strong>这个</strong>）</li>
</ul>
<h4 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h4><p><strong>1.默认绑定</strong></p>
<p>说完了this是什么，最重要的一点就是他是如何绑定的，来看下面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 1 ;</span><br><span class="line">    console.log(this.a);    // 10</span><br><span class="line">&#125;</span><br><span class="line">var a = 10;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这种就是典型的<strong>默认绑定</strong>，我们看看foo调用的位置，”光杆司令“，像 <strong>这种直接使用而不带任何修饰的函数调用</strong> ，就 <strong>默认且只能</strong> 应用 默认绑定。那默认绑定到哪呢，一般是<code>window</code>上，严格模式下 是<code>undefined</code>。</p>
<p><strong>2.隐性绑定</strong></p>
<p>直接上例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 10,</span><br><span class="line">    foo : foo</span><br><span class="line">&#125;</span><br><span class="line">foo();                // undefined</span><br><span class="line"></span><br><span class="line">obj.foo();            // 10</span><br></pre></td></tr></table></figure>

<p><code>foo()</code>的这个写法熟悉吗，就是我们刚刚写的默认绑定,等价于打印<code>window.a</code>,故输出<code>undefined</code> ,下面<code>obj.foo()</code>这种大家应该经常写，这其实就是我们马上要讨论的 <strong>隐性绑定</strong> 。函数foo执行的时候有了<strong>上下文对象</strong>，即 <code>obj</code>。这种情况下，<strong>函数里的this默认绑定为上下文对象</strong>，等价于打印<code>obj.a</code>,故输出<code>10</code> 。如果是链性的关系，比如 <code>aa.bb.obj.foo();</code>上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。</p>
<p><strong>3.显性绑定</strong></p>
<p>隐性绑定存在一个致命的限制：<strong>上下文中必须包含该函数</strong>，例：<code>var obj = &#123; foo : foo &#125;</code>,如果上下文不包含我们的函数用隐性绑定明显是要出错的，<strong>不可能每个对象都要加这个函数</strong> ,那样的话扩展,维护性太差了，我们接下来聊的就是直接 <strong>给函数强制性绑定this</strong>。而这里我们就要用到js提供的函数call和apply了。<strong>他们的作用都是改变函数this的指向，第一个参数都是设置this对象</strong>。</p>
<p>两个函数的区别：</p>
<ol>
<li>call从第二个参数开始所有的参数都是 原函数的参数。</li>
<li>apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(a,b)&#123;</span><br><span class="line">    console.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(null,&#x27;海洋&#x27;,&#x27;饼干&#x27;);        // 海洋饼干  这里this指向不重要就写null了</span><br><span class="line">foo.apply(null, [&#x27;海洋&#x27;,&#x27;饼干&#x27;] );     // 海洋饼干</span><br></pre></td></tr></table></figure>

<p>除了 call，apply函数以外，还有一个改变this的函数 bind ，它和call,apply都不同。<strong>bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回</strong>。例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123; a : 10 &#125;;</span><br><span class="line"></span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line">foo();                    // 10</span><br></pre></td></tr></table></figure>

<p>显性绑定就是通过<strong>call,apply,bind</strong>这三个函数实现this的指向改变的，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 10           </span><br><span class="line">&#125;</span><br><span class="line">//将this指向obj</span><br><span class="line">foo.call(obj);        // 10</span><br></pre></td></tr></table></figure>

<p><strong>4.new绑定</strong></p>
<p>js的new和传统的面向对象语言的new的作用都是创建一个新的对象，但是他们的机制完全不同。创建一个新对象少不了一个概念，那就是<code>构造函数</code>，传统的面向对象 构造函数 是类里的一种特殊函数，要创建对象时使用<code>new 类名()</code>的形式去调用类中的构造函数，而js中就不一样了。<strong>js中的只要用new修饰的 函数就是’构造函数’</strong>，准确来说是 **函数的<code>构造调用</code>**，因为在js中并不存在所谓的’构造函数’。那么用new 做到函数的<code>构造调用</code>后，js帮我们做了什么工作呢:</p>
<ol>
<li>创建一个新对象。</li>
<li>把这个新对象的<code>__proto__</code>属性指向 原函数的<code>prototype</code>属性。(即继承原函数的原型)</li>
<li><strong>将这个新对象绑定到 此函数的this上</strong> 。</li>
<li>返回新对象，如果这个函数没有返回其他<strong>对象</strong>。</li>
</ol>
<p>上例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    this.a = 10;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">foo();                    // window对象</span><br><span class="line">console.log(window.a);    // 10   默认绑定</span><br><span class="line"></span><br><span class="line">var obj = new foo();      // foo&#123; a : 10 &#125;  创建的新对象的默认名为函数名</span><br><span class="line">                          // 然后等价于 foo &#123; a : 10 &#125;;  var obj = foo;</span><br><span class="line">console.log(obj.a);       // 10    new绑定</span><br></pre></td></tr></table></figure>

<p><strong>使用new调用函数后，函数会 *以自己的名字 命名 和 创建* 一个新的对象，并返回。</strong></p>
<p>特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    this.a = 10;</span><br><span class="line">    return new String(&quot;捣蛋鬼&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new foo();</span><br><span class="line">console.log(obj.a);       // undefined</span><br><span class="line">console.log(obj);         // &quot;捣蛋鬼&quot;</span><br></pre></td></tr></table></figure>

<p>this绑定优先级：<strong>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p>
<p><a href="https://segmentfault.com/a/1190000011194676">深入理解 js this 绑定 ( 无需死记硬背，尾部有总结和面试题解析 ) – SegmentFault 思否</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript类型转换</title>
    <url>/2022/04/01/javascript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>Number() 转换为数字， String() 转换为字符串， Boolean() 转化为布尔值。</p>
<span id="more"></span>

<h2 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><p>在 JavaScript 中有 5 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p>你可以使用 <strong>typeof</strong> 操作符来查看 JavaScript 变量的数据类型。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof` `&quot;John&quot;`         `// 返回 string``typeof` `3.14          ``// 返回 number``typeof` `NaN          ``// 返回 number``typeof` `false`         `// 返回 boolean``typeof` `[1,2,3,4]       ``// 返回 object``typeof` `&#123;name:``&#x27;John&#x27;``, age:34&#125; ``// 返回 object``typeof` `new` `Date()       ``// 返回 object``typeof` `function` `() &#123;&#125;     ``// 返回 function``typeof` `myCar         ``// 返回 undefined (如果 myCar 没有声明)``typeof` `null`          `// 返回 object</span><br></pre></td></tr></table></figure>

<p>请注意：</p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组(Array)的数据类型是 object</li>
<li>日期(Date)的数据类型为 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型为 undefined</li>
</ul>
<p>如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 <strong>typeof</strong> 来判断他们的类型，因为都是 返回 object。</p>
<h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;John&quot;``.constructor         ``// 返回函数 String() &#123; [native code] &#125;``(3.14).constructor         ``// 返回函数 Number() &#123; [native code] &#125;``false``.constructor         ``// 返回函数 Boolean() &#123; [native code] &#125;``[1,2,3,4].constructor       ``// 返回函数 Array()  &#123; [native code] &#125;``&#123;name:``&#x27;John&#x27;``, age:34&#125;.constructor ``// 返回函数 Object() &#123; [native code] &#125;``new` `Date().constructor       ``// 返回函数 Date()  &#123; [native code] &#125;``function` `() &#123;&#125;.constructor     ``// 返回函数 Function()&#123; [native code] &#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用 constructor 属性来查看对象是否为数组 (包含字符串 “Array”)：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function` `isArray(myArray) &#123;``  ``return` `myArray.constructor.toString().indexOf(``&quot;Array&quot;``) &gt; -1;``&#125;</span><br></pre></td></tr></table></figure>



<p>你可以使用 constructor 属性来查看对象是否为日期 (包含字符串 “Date”)：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function` `isDate(myDate) &#123;``  ``return` `myDate.constructor.toString().indexOf(``&quot;Date&quot;``) &gt; -1;``&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JavaScript-类型转换"><a href="#JavaScript-类型转换" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h2><p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h2 id="将数字转换为字符串"><a href="#将数字转换为字符串" class="headerlink" title="将数字转换为字符串"></a>将数字转换为字符串</h2><p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。</p>
<p>该方法可用于任何类型的数字，字母，变量，表达式：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String(x)     ``// 将变量 x 转换为字符串并返回``String(123)    ``// 将数字 123 转换为字符串并返回``String(100 + 23) ``// 将数字表达式转换为字符串并返回</span><br></pre></td></tr></table></figure>



<p>Number 方法 <strong>toString()</strong> 也是有同样的效果。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.toString()``(123).toString()``(100 + 23).toString()</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://www.nowcoder.com/tutorial/10009/30010ec441e142be9f7e941d320d0297">Number 方法</a> 章节中，你可以找到更多数字转换为字符串的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">toExponential()</td>
<td align="center">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="center">toFixed()</td>
<td align="center">把数字转换为字符串，结果的小数点后有指定位数的数字。</td>
</tr>
<tr>
<td align="center">toPrecision()</td>
<td align="center">把数字格式化为指定的长度。</td>
</tr>
</tbody></table>
<h2 id="将布尔值转换为字符串"><a href="#将布尔值转换为字符串" class="headerlink" title="将布尔值转换为字符串"></a>将布尔值转换为字符串</h2><p>全局方法 <strong>String()</strong> 可以将布尔值转换为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String(``false``)    ``// 返回 &quot;false&quot;``String(``true``)     ``// 返回 &quot;true&quot;</span><br></pre></td></tr></table></figure>

<p>Boolean 方法 <strong>toString()</strong> 也有相同的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false``.toString()   ``// 返回 &quot;false&quot;``true``.toString()   ``// 返回 &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h2 id="将日期转换为字符串"><a href="#将日期转换为字符串" class="headerlink" title="将日期转换为字符串"></a>将日期转换为字符串</h2><p>Date() 返回字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date() ``// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span><br></pre></td></tr></table></figure>

<p>全局方法 String() 可以将日期对象转换为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String(``new` `Date()) ``// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span><br></pre></td></tr></table></figure>

<p>Date 方法 <strong>toString()</strong> 也有相同的效果。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = ``new` `Date()``obj.toString()  ``// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://www.nowcoder.com/tutorial/10009/cef9e4a498c14ec5a9cf897eac36f3bf">Date 方法</a> 章节中，你可以查看更多关于日期转换为字符串的函数：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getDate()</td>
<td align="center">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="center">getDay()</td>
<td align="center">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="center">getFullYear()</td>
<td align="center">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="center">getHours()</td>
<td align="center">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="center">getMilliseconds()</td>
<td align="center">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="center">getMinutes()</td>
<td align="center">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center">getMonth()</td>
<td align="center">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="center">getSeconds()</td>
<td align="center">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center">getTime()</td>
<td align="center">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<h2 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h2><p>全局方法 <strong>Number()</strong> 可以将字符串转换为数字。</p>
<p>字符串包含数字(如 “3.14”) 转换为数字 (如 3.14).</p>
<p>空字符串转换为 0。</p>
<p>其他的字符串会转换为 NaN (不是个数字)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number(``&quot;3.14&quot;``)  ``// 返回 3.14``Number(``&quot; &quot;``)    ``// 返回 0``Number(``&quot;&quot;``)    ``// 返回 0``Number(``&quot;99 88&quot;``)  ``// 返回 NaN</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://www.nowcoder.com/tutorial/10009/30010ec441e142be9f7e941d320d0297">Number 方法</a> 章节中，你可以查看到更多关于字符串转为数字的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">parseFloat()</td>
<td align="center">解析一个字符串，并返回一个浮点数。</td>
</tr>
<tr>
<td align="center">parseInt()</td>
<td align="center">解析一个字符串，并返回一个整数。</td>
</tr>
</tbody></table>
<h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符 +"></a>一元运算符 +</h2><p><strong>Operator +</strong> 可用于将变量转换为数字：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var` `y = ``&quot;5&quot;``;   ``// y 是一个字符串``var` `x = + y;   ``// x 是一个数字</span><br></pre></td></tr></table></figure>



<p>如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字)：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var` `y = ``&quot;John&quot;``;  ``// y 是一个字符串``var` `x = + y;   ``// x 是一个数字 (NaN)</span><br></pre></td></tr></table></figure>

<h2 id="将布尔值转换为数字"><a href="#将布尔值转换为数字" class="headerlink" title="将布尔值转换为数字"></a>将布尔值转换为数字</h2><p>全局方法 <strong>Number()</strong> 可将布尔值转换为数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number(``false``)   ``// 返回 0``Number(``true``)   ``// 返回 1</span><br></pre></td></tr></table></figure>

<h2 id="将日期转换为数字"><a href="#将日期转换为数字" class="headerlink" title="将日期转换为数字"></a>将日期转换为数字</h2><p>全局方法 <strong>Number()</strong> 可将日期转换为数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = ``new` `Date();``Number(d)     ``// 返回 1404568027739</span><br></pre></td></tr></table></figure>

<p>日期方法 <strong>getTime()</strong> 也有相同的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = ``new` `Date();``d.getTime()    ``// 返回 1404568027739</span><br></pre></td></tr></table></figure>

<h2 id="自动转换类型"><a href="#自动转换类型" class="headerlink" title="自动转换类型"></a>自动转换类型</h2><p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。</p>
<p>以下输出结果不是你所期望的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 + ``null`  `// 返回 5     null 转换为 0``&quot;5&quot;` `+ ``null` `// 返回&quot;5null&quot;  null 转换为 &quot;null&quot;``&quot;5&quot;` `+ 1   ``// 返回 &quot;51&quot;   1 转换为 &quot;1&quot;``&quot;5&quot;` `- 1   ``// 返回 4     &quot;5&quot; 转换为 5</span><br></pre></td></tr></table></figure>

<h2 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h2><p>当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.getElementById(``&quot;demo&quot;``).innerHTML = myVar;` `myVar = &#123;name:``&quot;Fjohn&quot;``&#125; ``// toString 转换为 &quot;[object Object]&quot;``myVar = [1,2,3,4]    ``// toString 转换为 &quot;1,2,3,4&quot;``myVar = ``new` `Date()   ``// toString 转换为 &quot;Fri Jul 18 2014 09:08:55 GMT+0200&quot;</span><br></pre></td></tr></table></figure>

<p>数字和布尔值也经常相互转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myVar = 123       ``// toString 转换为 &quot;123&quot;``myVar = ``true`      `// toString 转换为 &quot;true&quot;``myVar = ``false`      `// toString 转换为 &quot;false&quot;</span><br></pre></td></tr></table></figure>

<p>下表展示了使用不同的数值转换为数字(Number), 字符串(String), 布尔值(Boolean)：</p>
<table>
<thead>
<tr>
<th align="center">原始值</th>
<th align="center">转换为数字</th>
<th align="center">转换为字符串</th>
<th align="center">转换为布尔值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">false</td>
<td align="center">0</td>
<td align="center">“false”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">true</td>
<td align="center">1</td>
<td align="center">“true”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">“0”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">“1”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“0”</td>
<td align="center">0</td>
<td align="center">“0”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“000”</td>
<td align="center">0</td>
<td align="center">“000”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“1”</td>
<td align="center">1</td>
<td align="center">“1”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">NaN</td>
<td align="center">NaN</td>
<td align="center">“NaN”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">Infinity</td>
<td align="center">Infinity</td>
<td align="center">“Infinity”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">-Infinity</td>
<td align="center">-Infinity</td>
<td align="center">“-Infinity”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">0</td>
<td align="center">“”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“20”</td>
<td align="center">20</td>
<td align="center">“20”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“Nowcoder”</td>
<td align="center">NaN</td>
<td align="center">“Nowcoder”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">0</td>
<td align="center">“”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">[20]</td>
<td align="center">20</td>
<td align="center">“20”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">[10,20]</td>
<td align="center">NaN</td>
<td align="center">“10,20”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">[“Nowcoder”]</td>
<td align="center">NaN</td>
<td align="center">“Nowcoder”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">[“Nowcoder”,”Google”]</td>
<td align="center">NaN</td>
<td align="center">“Nowcoder,Google”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">function(){}</td>
<td align="center">NaN</td>
<td align="center">“function(){}”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">{ }</td>
<td align="center">NaN</td>
<td align="center">“[object Object]”</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">0</td>
<td align="center">“null”</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">undefined</td>
<td align="center">NaN</td>
<td align="center">“undefined”</td>
<td align="center">false</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈表单</title>
    <url>/2022/04/01/%E8%B0%88%E8%B0%88%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<p>表单，常常用于提交用户向服务器发送的消息，应用非常广泛，而整个表单又可以分为表单控件、提示信息、表单域这三大内容。</p>
<span id="more"></span>

<h4 id="表单控件：-input-select-textarea-button"><a href="#表单控件：-input-select-textarea-button" class="headerlink" title="表单控件： input select textarea button"></a>表单控件： input select textarea button</h4><p>包含了具体的表单功能项：单行文本输入框、密码输入框、复选框、按钮</p>
<h4 id="提示信息：label"><a href="#提示信息：label" class="headerlink" title="提示信息：label"></a>提示信息：label</h4><p>表单中的说明性文字，提示用户进行填写和操作，可以绑定表单控件，扩大选择区域，label中的属性 for 可以用于绑定的表单控件，绑定方式：绑定id值与for值相同的表单控件</p>
<h4 id="表单域：form"><a href="#表单域：form" class="headerlink" title="表单域：form"></a>表单域：form</h4><p>类比一个容器，用于容纳所有表单组件和提示信息，可以通过他定义处理表单数据所用程序的url地址以及数据提交到服务器的方法（如果不定义，表单的数据将无法传送到后台服务器）,创建表单的基本语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&#x27;url地址&#x27; method=&#x27;提交方式&#x27; name=&#x27;表单名称&#x27;&gt;</span><br><span class="line">  表单控件...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>其常用的属性如下：</p>
<ul>
<li>action:在表单收集到信息后，需要将信息传递给服务器，action属性用于指定接受并处理表单数据的服务器程序的url地址</li>
<li>method:用于设置表单数据的提交方式(get&#x2F;post)</li>
<li>name:用于指定表单的名称，以区别同一页面的多个表单</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最上方组成</span><br><span class="line">网址（action的值）？请求内容名称（input中的name属性值）=请求值（input中的value属性值）&amp;请求内容=请求值</span><br></pre></td></tr></table></figure>

<h2 id="input控件（最常用）"><a href="#input控件（最常用）" class="headerlink" title="input控件（最常用）"></a>input控件（最常用）</h2><p>input标签为单标签，其常用属性如下表</p>
<table>
<thead>
<tr>
<th><strong>常用属性</strong></th>
<th><strong>属性值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>自定义</td>
<td>绑定对应label</td>
</tr>
<tr>
<td>type</td>
<td>见下表</td>
<td>控制input的类型</td>
</tr>
<tr>
<td>name</td>
<td>自定义</td>
<td>控件名称  作为提交数据时的key</td>
</tr>
<tr>
<td>value</td>
<td>自定义 输入</td>
<td>input控件中的默认文本</td>
</tr>
<tr>
<td>size</td>
<td>正整数</td>
<td>input在页面中的显示宽度</td>
</tr>
<tr>
<td>checked</td>
<td>checked（状态属性）</td>
<td>定义选择控件默认被选中的项</td>
</tr>
<tr>
<td>maxlength</td>
<td>正整数</td>
<td>规定空间容许输入的最大字符数</td>
</tr>
<tr>
<td>required</td>
<td>required</td>
<td>必填</td>
</tr>
<tr>
<td>readonly</td>
<td>readonly</td>
<td>内容只读</td>
</tr>
<tr>
<td>placeholder</td>
<td>文本</td>
<td>用户输入提示文本</td>
</tr>
<tr>
<td>multiple</td>
<td>multiple</td>
<td>文件上传可选多文件</td>
</tr>
</tbody></table>
<p>﻿</p>
<p>type常规值如下图：</p>
<table>
<thead>
<tr>
<th><strong>常用类型属性</strong></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>email</td>
<td>电子邮件（非有效限制）</td>
</tr>
<tr>
<td>search</td>
<td>查询框（点击x课清除内容）</td>
</tr>
<tr>
<td>text</td>
<td>单行文本输入框（明文）使用频率最高</td>
</tr>
<tr>
<td>password</td>
<td>密码输入框（密文）</td>
</tr>
<tr>
<td>radio</td>
<td>单选按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>复选框（多选）</td>
</tr>
<tr>
<td>button</td>
<td>按钮，主要通过js进行互动</td>
</tr>
<tr>
<td>submit</td>
<td>提交按钮，将表单数据发送至服务器</td>
</tr>
<tr>
<td>reset</td>
<td>重置按钮，清除表单中的所有数据</td>
</tr>
<tr>
<td>image</td>
<td>图像形式的提交按钮，需要添加url属性（图片的地址）</td>
</tr>
<tr>
<td>hidden</td>
<td>隐藏的输入文本（输入不显示、防窥屏）</td>
</tr>
<tr>
<td>file</td>
<td>供文件上传（multiple属性可以开启多文件选择）</td>
</tr>
<tr>
<td>number</td>
<td>只能输入数字</td>
</tr>
<tr>
<td>date</td>
<td>日期选择（年月日）</td>
</tr>
<tr>
<td>tel</td>
<td>电话号码（非有效限制）</td>
</tr>
<tr>
<td>time</td>
<td>时间选择</td>
</tr>
</tbody></table>
<p>﻿</p>
<p>text属性的常见css设置：</p>
<ul>
<li>outline:点击时的聚焦边框效果，如果想要去除可以设置outline:0;同时还可以设置颜色、边框宽度以及边框样式，即outline-color、outline-width和outline-style;</li>
</ul>
<h3 id="textarea控件"><a href="#textarea控件" class="headerlink" title="textarea控件"></a>textarea控件</h3><p>如果需要输入大量信息，需要使用textarea标签，能够轻松地创建多行文本输入框，基本语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea cols=&#x27;每行中的字符数&#x27; rows=&#x27;显示的行数&#x27;&gt;</span><br><span class="line">  文本内容</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>

<p>textarea默认情况下是可以进行拖动延展的，可以在css中设置resize:none取消拖动。</p>
<h3 id="select控件"><a href="#select控件" class="headerlink" title="select控件"></a>select控件</h3><p>select控件，就是非常常见的下拉选择框，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option&gt;选项一&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;选项二&lt;/option&gt;</span><br><span class="line">  &lt;option&gt;选项三&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>类似于ul与li的关系，select中至少包含一对option，在option中定义selected&#x3D;’selected’时，当前项即为默认选中项。同样的，可以设置select的border和outline以及background-color等样式</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
