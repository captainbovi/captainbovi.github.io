<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>点滴生活 点滴人生</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-27T09:57:35.985Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>bovi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础数据与引用数据类型</title>
    <link href="http://example.com/2022/06/19/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/06/19/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-06-18T17:55:24.000Z</published>
    <updated>2022-06-27T09:57:35.985Z</updated>
    
    
    <summary type="html">&lt;p&gt;基础数据类型：String、Number、Null、Undefine&lt;/p&gt;
&lt;p&gt;引用数据类型：Object&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://example.com/2022/04/14/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/04/14/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-14T14:36:56.000Z</published>
    <updated>2022-04-22T07:44:37.826Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是KMP算法&quot;&gt;&lt;a href=&quot;#什么是KMP算法&quot; class=&quot;headerlink&quot; title=&quot;什么是KMP算法&quot;&gt;&lt;/a&gt;什么是KMP算法&lt;/h2&gt;&lt;p&gt;KMP算法由Knuth、Morris和Pratt三位学者发明，这个算法取三主要名字的首字母，故叫做KMP算法。&lt;/p&gt;
&lt;p&gt;这个算法用于&lt;strong&gt;字符串匹配&lt;/strong&gt;，其核心思想就是利用已经匹配的部分，来简化整个重新匹配的机制，避免每次匹配失败都从头再来。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>非父子组件间的通信</title>
    <link href="http://example.com/2022/04/04/%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2022/04/04/%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2022-04-03T18:37:58.000Z</published>
    <updated>2022-04-05T04:11:06.345Z</updated>
    
    
    <summary type="html">&lt;p&gt;Vue中父子组件间进行通信可以使用 refs或refs 或refs或children 来进行父组件访问子组件的操作，通过$parent进行子组件访问父组件的操作(详情见文章&lt;a href=&quot;https://juejin.cn/post/7082437425108090917&quot;&gt;组件访问（父访子 与 子访父） - 掘金 (juejin.cn)&lt;/a&gt;), 那么如何实现非父子组件间的通信呢？基本思路如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="http://example.com/2022/04/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/04/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-03T18:31:54.000Z</published>
    <updated>2022-04-03T18:36:24.299Z</updated>
    
    
    <summary type="html">&lt;p&gt;vue是如何实现响应式的？ 随之而来便有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;vue是如何实现监听实例中的属性的变化的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当数据发生变化时，vue是如何做到通知相应的组件，并使界面实现刷新&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期</title>
    <link href="http://example.com/2022/04/04/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/04/04/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-04-03T18:31:40.000Z</published>
    <updated>2022-04-03T18:36:35.471Z</updated>
    
    
    <summary type="html">&lt;p&gt;Vue实例从创建直至销毁的过程，叫做Vue的生命周期。即开始创建、初始化数据、编译模板、挂载dom、渲染、更新、卸载等一些列过程，我们将其称之为vue的生命周期。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>axios的基本使用</title>
    <link href="http://example.com/2022/04/04/axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/04/04/axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-03T18:31:26.000Z</published>
    <updated>2022-04-03T18:53:32.716Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是axios&quot;&gt;&lt;a href=&quot;#什么是axios&quot; class=&quot;headerlink&quot; title=&quot;什么是axios&quot;&gt;&lt;/a&gt;什么是axios&lt;/h3&gt;&lt;p&gt;axios 是一个基于&lt;a href=&quot;https://link.juejin.cn/?target=https://so.csdn.net/so/search?q=Promise&amp;spm=1001.2101.3001.7020&quot;&gt;Promise&lt;/a&gt;的  用于浏览器和 nodejs 的 HTTP 客户端。简单的理解就是ajax的封装。他有一下这些特点：&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://example.com/2022/04/04/Vuex/"/>
    <id>http://example.com/2022/04/04/Vuex/</id>
    <published>2022-04-03T18:31:10.000Z</published>
    <updated>2022-04-03T18:59:02.041Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是Vuex，它是干什么的&quot;&gt;&lt;a href=&quot;#什么是Vuex，它是干什么的&quot; class=&quot;headerlink&quot; title=&quot;什么是Vuex，它是干什么的&quot;&gt;&lt;/a&gt;什么是Vuex，它是干什么的&lt;/h3&gt;&lt;p&gt;官方解释：他是一个专为Vue.js应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;，它采用&lt;strong&gt;集中式存储管理&lt;/strong&gt;应用所有组件的状态，Vuex是响应式的。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue-router</title>
    <link href="http://example.com/2022/04/04/vue-router/"/>
    <id>http://example.com/2022/04/04/vue-router/</id>
    <published>2022-04-03T18:30:56.000Z</published>
    <updated>2022-04-03T18:36:53.489Z</updated>
    
    
    <summary type="html">&lt;p&gt;前置知识：&lt;/p&gt;
&lt;h4 id=&quot;什么是路由&quot;&gt;&lt;a href=&quot;#什么是路由&quot; class=&quot;headerlink&quot; title=&quot;什么是路由&quot;&gt;&lt;/a&gt;什么是路由&lt;/h4&gt;&lt;p&gt;所谓路由（routing）就是通过互联网的网络把信息从原地址传输到目的地址的活动（说了，但没完全说）。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue-cli</title>
    <link href="http://example.com/2022/04/04/Vue-cli/"/>
    <id>http://example.com/2022/04/04/Vue-cli/</id>
    <published>2022-04-03T18:15:14.000Z</published>
    <updated>2022-04-03T18:36:59.393Z</updated>
    
    
    <summary type="html">&lt;p&gt;Cli（Command-Line interface），即命令行界面，俗称脚手架，大型的前端开发框架如react、vue都有自己的官方CLI，CLI可以帮助开发者搭建开发环境并且配置webpack。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>es6模块化导入导出</title>
    <link href="http://example.com/2022/04/04/es6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://example.com/2022/04/04/es6%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</id>
    <published>2022-04-03T18:08:03.000Z</published>
    <updated>2022-04-03T18:08:49.999Z</updated>
    
    
    <summary type="html">&lt;p&gt;模块化，能够有效的提高多人开发时的效率，同时避免出现全局变量命名重复等比较严重的问题。常见的模块化导入导出的规范有：CommonJS、AMD、CMD、ES6的modules规范，其中只有ES6的模块规范不需要底层支持就可以直接在浏览器中运行。这里使用ES6的规范进行模块化导入导出&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>slot介绍与应用</title>
    <link href="http://example.com/2022/04/04/slot%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2022/04/04/slot%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2022-04-03T17:58:45.000Z</published>
    <updated>2022-04-03T17:59:53.337Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是slot、插槽的基本使用&quot;&gt;&lt;a href=&quot;#什么是slot、插槽的基本使用&quot; class=&quot;headerlink&quot; title=&quot;什么是slot、插槽的基本使用&quot;&gt;&lt;/a&gt;什么是slot、插槽的基本使用&lt;/h4&gt;&lt;p&gt;slot，即插槽，是为了提高组件复用性而孕育的标签，在组件模板中添加，可以预留位置，用于后续的补充替换，实现一个组件，多个表现样式，极大提升组件的复用性。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>组件访问</title>
    <link href="http://example.com/2022/04/04/%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE/"/>
    <id>http://example.com/2022/04/04/%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE/</id>
    <published>2022-04-03T17:55:24.000Z</published>
    <updated>2022-04-03T18:56:29.391Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们想要实现在父组件上进行操作后访问子组件的功能或者数据时，可以使用 refs或refs 或refs或children 来实现。同样的，先注册一个实例以及一个子组件&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>父子组件通信双向绑定</title>
    <link href="http://example.com/2022/04/04/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://example.com/2022/04/04/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</id>
    <published>2022-04-03T17:52:34.000Z</published>
    <updated>2022-04-03T18:00:36.004Z</updated>
    
    
    <summary type="html">&lt;p&gt;将父传子，子传父稍微结合一下，实现父子组件通信双向绑定。最终实现在子组件的输入框中输入数据，实时改变父组件中的数据&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>父子组件传值</title>
    <link href="http://example.com/2022/04/04/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://example.com/2022/04/04/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2022-04-03T17:48:38.000Z</published>
    <updated>2022-04-03T18:00:30.307Z</updated>
    
    
    <summary type="html">&lt;p&gt;子件和父组件之间难免会涉及到数据传输的问题，尤其是在父（根）组件通过ajax请求获取数据后，在传入子组件中得以显示时。传输方式便显得尤为重要。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue创建组件</title>
    <link href="http://example.com/2022/04/04/vue%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2022/04/04/vue%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6/</id>
    <published>2022-04-03T17:40:41.000Z</published>
    <updated>2022-04-03T18:02:06.672Z</updated>
    
    
    <summary type="html">&lt;p&gt;Vue组件创建两大步：1.创建组件 2.注册组件&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>v-model的常用事件修饰符</title>
    <link href="http://example.com/2022/04/04/v-model%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://example.com/2022/04/04/v-model%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2022-04-03T17:39:08.000Z</published>
    <updated>2022-04-03T18:00:05.999Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;lazy修饰符&quot;&gt;&lt;a href=&quot;#lazy修饰符&quot; class=&quot;headerlink&quot; title=&quot;lazy修饰符&quot;&gt;&lt;/a&gt;lazy修饰符&lt;/h4&gt;&lt;p&gt;默认情况下，v-model是与输入框中的value同步的，一旦有数据发生改变，data中与其双向绑定的数据也随之改变。使用lazy修饰符可以让数据在失去焦点或者回车时再进行更新。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue初步</title>
    <link href="http://example.com/2022/04/04/Vue%E5%88%9D%E6%AD%A5/"/>
    <id>http://example.com/2022/04/04/Vue%E5%88%9D%E6%AD%A5/</id>
    <published>2022-04-03T17:37:00.000Z</published>
    <updated>2022-04-03T18:00:14.352Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是工程化&quot;&gt;&lt;a href=&quot;#什么是工程化&quot; class=&quot;headerlink&quot; title=&quot;什么是工程化&quot;&gt;&lt;/a&gt;什么是工程化&lt;/h2&gt;&lt;p&gt;你以为的前端开发：老三样，需要美化页面：bootstrap!,需要实现网页布局：Layui（然后最后写出个DEMO）&lt;/p&gt;
&lt;p&gt;实际的前端开发：模块化+组件化+规范化+自动化（介都是嘛玩意儿啊）&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>神奇的display</title>
    <link href="http://example.com/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/"/>
    <id>http://example.com/2022/04/01/%E7%A5%9E%E5%A5%87%E7%9A%84display/</id>
    <published>2022-04-01T13:08:25.000Z</published>
    <updated>2022-04-21T15:43:39.240Z</updated>
    
    
    <summary type="html">&lt;p&gt;display可是个神奇的东西，通过修改display可以帮助组件实现“逆天改命”，变成其他组件的“模样”，当然，修炼之路不乏贫困，让我们一起来看看都有些什么神奇的display可供更改。&lt;/p&gt;</summary>
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>图片自适应大小</title>
    <link href="http://example.com/2022/04/01/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/"/>
    <id>http://example.com/2022/04/01/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</id>
    <published>2022-04-01T13:08:06.000Z</published>
    <updated>2022-04-01T13:28:16.960Z</updated>
    
    
    <summary type="html">&lt;p&gt;在一般设计中，插入图片有两种方式，一是在组件中添加background属性，一是通过&lt;img&gt;组件。两种方式实现自适应的方式大同小异。&lt;/p&gt;</summary>
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>居中</title>
    <link href="http://example.com/2022/04/01/%E5%B1%85%E4%B8%AD/"/>
    <id>http://example.com/2022/04/01/%E5%B1%85%E4%B8%AD/</id>
    <published>2022-04-01T13:07:47.000Z</published>
    <updated>2022-04-02T05:35:14.856Z</updated>
    
    
    <summary type="html">&lt;p&gt;居中的方式有很多，其中，有不少是伪居中，具体表现为看样子是居中了，但是详细查看位置后发现其实没有居中，在这里提供两种居中思路：绝对位置居中以及弹性盒子居中&lt;/p&gt;</summary>
    
    
    
    <category term="css" scheme="http://example.com/categories/css/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
</feed>
